namespace: SysmelC definition: {
public: [
Enum: TokenKind withBaseType: UInt8 values: #{
    NullToken: 0u8.
    EndOfSource:.
    Error:.

    Character:.
    Float:.
    Identifier:.
    Nat:.
    Keyword:.
    MultiKeyword:.
    Operator:.
    String:.
    Symbol:.

    LeftParent:.
    RightParent:.
    LeftBracket:.
    RightBracket:.
    LeftCurlyBracket:.
    RightCurlyBracket:.

    LessThan:.
    GreaterThan:.
    Star:.
    Question:.
    Bang:.
    Dollar:.
    Colon:.
    ColonColon:.
    Bar:.
    Assignment:.
    Semicolon:.
    Comma:.
    Dot:.
    Ellipsis:.
    BindOperator:.
    Quote:.
    QuasiQuote:.
    QuasiUnquote:.
    Splice:.

    ByteArrayStart:.
    DictionaryStart:.
    LiteralArrayStart:.    
}.

Record: ScannedToken withFields: #{
    kind: TokenKind.
    sourcePosition: SourcePosition.
    errorMessage: String
}.

Record: ScannerState withFields: #{
    sourceCode: SourceCode.
    text: String.
    textSize: UInt32.
    position: UInt32.
    line: UInt32.
    column: UInt32.
    isPreviousCR: Boolean
}.

$makeScannerStateForSourceCode($(SourceCode)sourceCode :: ScannerState) 
    := ScannerState#{
        sourceCode: sourceCode.
        text: sourceCode text.
        textSize: sourceCode text size.
        position: 0.
        line: 1.
        column: 1.
        isPreviousCR: false
    }.
].

ScannerState
    withSelector: #atEnd addMethod: {|$(ScannerState)self :: Boolean |
        self position >= self textSize 
    };
    withSelector: #peekAt: addMethod: {|$(ScannerState)self $(UInt32)offset :: Int32 |
        if: (self position + offset) < self textSize
        then: (self text at: self position + offset) asInt32
        else: 1i32 negated
        
    };
    withSelector: #peek addMethod: {|$(ScannerState)self $(UInt32)offset :: Int32 |
        self peekAt: 0u32
    };
    withSelector: #advance addMethod: {|$(ScannerState)self :: Void |
        assert: self atEnd not.
        $c := (self text at: self position) asInt32.
        if: c = '\r'i32 then: {
            self line: self line + 1u32.
            self column: 1u32.
            self isPreviousCR: true
        } else: {
            if: c = '\n'i32 then: {
                if: self isPreviousCR not then: {
                    self line: self line + 1u32.
                    self column: 1u32
                }.
                self isPreviousCR: false
            } else: {
                if: c = '\t'i32 then: {
                    self column: (self column + 4)%4 * 4 + 1.
                    self isPreviousCR: false
                }
                else: {
                    self column: self column + 1.
                    self isPreviousCR: false
                }
            }
        }.

        self position: self position + 1i32.
        void
    };
    withSelector: #advance: addMethod: {|$(ScannerState)self $(UInt32) count :: Void |
        $!i := 0u32.
        while: (i < count) do: {
            self advance
        } continueWith: (i := i + 1u32)
    }.

$skipWhite($(ScannerState)state :: ScannedToken) := {
    $!hasSeenComments := false.
    do: {
        ## Skip whitespaces.
        while: (state atEnd not && (state peek <= ' 'u32)) do: {
            state advance
        }.

        if: (state peek = '#'u32) then: {
            ## Singleline
            if:((state peekAt: 1u32) = '#'u32) then: {
                state advance: 2u32.
                while: (state atEnd not && state peek ~= '\n' && state peek ~= '\r' ) do: {
                    state advance
                }.

                hasSeenComments := true.
            }
            else: {
                ## Multiline
                if: ((state peekAt: 1) = '*'u32) then: {

                }
            }
            
        }

    } while: (hasSeenComments).

    ScannedToken(TokenKind NullToken)
}.

$scanSingleToken($(ScannerState)state :: ScannerToken) := {
    $whiteErrorToken := skipWhite(state).
    if: whiteErrorToken kind ~= TokenKind NullToken then: {
        return: whiteErrorToken
    }.
    printLine("TODO: Beyond white").
    ScannedToken(TokenKind EndOfSource)
}.

public: [
    $scanSourceCode($(SourceCode)sourceCode :: OrderedCollection) := {
        $list := OrderedCollection().
        $state := makeScannerStateForSourceCode(sourceCode).
        $!scannedToken := ScannedToken(TokenKind NullToken).
        do: {
            scannedToken := scanSingleToken(state).
            list add: scannedToken
        } while: (scannedToken kind ~= TokenKind EndOfSource).

        list
    }
]

$sourceCode := makeSourceCodeForString("  testing. testing").
printLine(sourceCode).
$scanResult := scanSourceCode(sourceCode).
printLine(scanResult).
}.



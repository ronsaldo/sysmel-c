namespace: SysmelC definition: {
public: [
    SemanticsState
        withSelector: #processDependentType:withEnvironment:forClosureFunction: addMethod: {
            | $(SemanticsState)self $(ParseTreeNode)functionDependentTypeNode $(FunctionAnalysisEnvironment)environment $(MidClosureFunction) closureFunction :: SysmelType |
            $functionDependentType := functionDependentTypeNode extractFunctionalDependentTypeNode.
            $argumentNodes := functionDependentType arguments.
            $processedArguments := OrderedCollection().
            $argumentTypes := OrderedCollection()

            $!i := 0. while: (i < argumentNodes size) do: {
                $argumentBindable := (argumentNodes at: i) extractBindableNameNode.
                
                $!argumentName := null.
                if: argumentBindable isAnonymous not then: {
                    argumentName := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: argumentBindable nameExpression.
                    argumentName := extractSymbolFromValue(argumentName value)
                }.
                $argumentTypeNode := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: argumentBindable typeExpression.
                $argumentType := extractTypeFromValue(argumentTypeNode value).
                argumentTypes add: argumentType.

                $midType := MidConstantType(argumentType).
                $midArgument := MidArgument#{
                    owner: closureFunction.
                    index: i asUInt32.
                    name: argumentName.
                    typeExpression: midType.
                    type: argumentType
                }.

                if: argumentBindable isAnonymous not then: {
                    Environment(environment) addLocalSymbol: argumentName withValue:
                        TypedValue(Value(SysmelMidValue(midArgument)). argumentType)
                }.

                processedArguments add: midArgument.
            } continueWith: (i := i + 1).

            closureFunction arguments: processedArguments asArray.
            $resultTypeNode := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: functionDependentType resultTypeExpression.
            $resultType := extractTypeFromValue(resultTypeNode value).

            $functionType := SysmelType(SysmelSimpleFunctionType#{
                common: SysmelTypeCommon#{

                }.
                supertype: getBasicIntrinsicTypes() function.
                isCompileTimePure: false.
                isVariadic: false.
                argumentTypes: argumentTypes asArray.
                resultType: resultType.
            }).

            closureFunction type: functionType.
            functionType
        };
        withSelector: #analyzeWithEnvironment:andCompileClosure: addMethod: {
        | $(SemanticsState)self $(Environment)environment $(ParseTreeFunctionNode)ast :: TypedValue |

            $midFunction := MidClosureFunction#{
                sourcePosition: ast sourcePosition.
                name: ast name.
                captures: [].
                arguments: []
            }.

            $interpretedFunction := SysmelCompiledFunction#{
                midIR: midFunction.
                isMacro: false.
            }.

            $analysisEnvironment := FunctionAnalysisEnvironment#{
                parent: environment.
                localSymbols: SymbolHashtable().
            }.

            $functionType := self processDependentType: ast functionDependentType withEnvironment: analysisEnvironment forClosureFunction: midFunction.

            if: ast isAnonymous not then: {
                interpretedFunction name: ast name.
                environment addLocalSymbol: ast name withValue: TypedValue(Value(SysmelFunctionValue(SysmelFunction(interpretedFunction))). functionType).
            }.

            $midBuilder := midFunction makeBuilder.
            $bodyResult := self analyzeWithEnvironment: Environment(analysisEnvironment)
                andCompileClosure: midBuilder withBody: ast bodyExpression.
            midBuilder returnValue: bodyResult.
            midBuilder finish.

            $functionValue := TypedValue(Value(SysmelFunctionValue(SysmelFunction(interpretedFunction))). functionType).
        };
        withSelector: #analyzeWithEnvironment:andCompileClosure:withBody: addMethod: {
            | $(SemanticsState)self $(Environment)environment $(MidFunctionBuilder)midBuilder $(ParseTreeNode)ast :: MidValue |
            match: ast ofType: ParseTreeNode withPatterns: #{
                ## Literals.
                $(ParseTreeLiteralIntegerNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantInteger: literal value.
                }.
                $(ParseTreeLiteralCharacterNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantCharacter: literal value.
                }.
                $(ParseTreeLiteralFloatNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantFloat: literal value.
                }.
                $(ParseTreeLiteralStringNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantString: literal value.
                }.
                $(ParseTreeLiteralSymbolNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantSymbol: literal value.
                }.
                
                ## Identifiers
                $(ParseTreeIdentifierReferenceNode)identifier : {
                    $value := environment lookupSymbolRecursively: identifier value.
                    if: value isInvalidErrorValue then: {
                        printLine(value getInvalidErrorValueMessage).
                        abort()
                    }.

                    if: value value isMidValue then: {
                        return: value value getMidValue 
                    }.

                    midBuilder sourcePosition: identifier sourcePosition.
                    return: (midBuilder constantValue: value value).
                }.
    
                ## Messages and applications
                $(ParseTreeMessageSendNode)messageSend : {
                    $receiverValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: messageSend receiver.
                    $selectorValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: messageSend selector.
                    $receiverType := receiverValue type.
                    $selectorSymbolValue := selectorValue value.
                    $arguments := messageSend arguments.
                    ##printLine("receiverValue " . receiverValue).
                    ##printLine("receiverType " . receiverType).
                    ##printLine("selectorSymbolValue " . selectorSymbolValue).

                    $method := receiverType lookupSelector: selectorSymbolValue.
                    ##printLine("Method:". method).
                    

                    if: method value isInvalidErrorValue then: {
                        ##printLine("Method not found.").

                        match: receiverType ofType: SysmelType withPatterns: #{
                            $(SysmelTupleAndRecordType)tupleAndRecord : {
                                ##printLine("tupleAndRecord ". arguments size).
                                if: arguments size = 0 then: {
                                    $fieldIndex := findIndexOfRecordFieldWithName(tupleAndRecord. selectorSymbolValue).
                                    if: fieldIndex >= 0 then: {
                                        ## Implicit getter.
                                        $fieldType := tupleAndRecord fields at: fieldIndex.
                                        ##printLine("Emit instruction for getting field ". fieldIndex).
                                        $extractInstruction := midBuilder fromComposite: receiverValue extractAtIndex: fieldIndex withType: fieldType.
                                        return: extractInstruction
                                    }
                                }.
                                if: arguments size = 1 then: {
                                    
                                    $selectorWithoutTrailingColon := selectorSymbolValue withoutTrailingColon.
                                    $fieldIndex := findIndexOfRecordFieldWithName(tupleAndRecord. selectorWithoutTrailingColon).
                                    ##printLine("Setter ". selectorWithoutTrailingColon . " fieldIndex ". fieldIndex).
                                    if: fieldIndex >= 0 then: {
                                        ## Implicit setter
                                        $setterValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: (arguments at: 0).
                                        $insertInstruction := midBuilder inComposite: receiverValue insertValue: setterValue atIndex: fieldIndex.
                                        return: insertInstruction
                                    }
                                }.
                            }.
                            _: {
                                ## Nothing required here. 
                            }
                        }.
                    }.

                    $invocationArguments := OrderedCollection().
                    $i := 0. while:(i < messageSend arguments size) do: {
                        $argument := messageSend arguments at: i.
                        $analyzedArgument := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: argument.
                        invocationArguments add: analyzedArgument.
                    } continueWith:(i := i + 1).

                    midBuilder sourcePosition: messageSend sourcePosition.
                    return: (midBuilder send: selectorValue to: receiverValue withArguments: invocationArguments asArray)
                }.
                $(ParseTreeFunctionApplicationNode)functionApplication : {
                    $functional := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: functionApplication functional.
                                    ## Is this a type constructor invocation?
                    if: isTypeValue(functional value) then: {
                        $typeToConstruct := extractTypeFromValue(functional value).
                        printLine("typeToConstruct: ". typeToConstruct).

                        $argumentCount := functionApplication arguments size.
                        $invocationArguments := Array new: argumentCount.
                        $!i := 0. while: (i < argumentCount) do: {
                            $argumentValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: (functionApplication arguments at: i).
                            invocationArguments at: i put: argumentValue
                        } continueWith: (i := i + 1).

                        if: (invocationArguments size = 1) && (invocationArguments at: 0) isImmutableDictionary then: {
                            if: isRecordType(typeToConstruct) then: {
                                $dictionaryArgument := invocationArguments at: 0.
                                $recordType := extractRecordType(typeToConstruct).
                                $constructionArguments := Array new: recordType fields size.

                                $associations := dictionaryArgument associations
                                $!j := 0. while: (j < associations size) do: {
                                    $assoc := associations at: j.
                                    $keySymbol := assoc key asSymbol.
                                    ##printLine(j. " keySymbol ". keySymbol).
                                    $fieldIndex := findIndexOfRecordFieldWithName(recordType. keySymbol).
                                    if: (fieldIndex < 0) || (fieldIndex >= constructionArguments size) then: {
                                        printLine("Invalid field index [". fieldIndex. "] for construction of a ". recordType name).
                                        abort()
                                    } else: {
                                        constructionArguments at: fieldIndex put: assoc value
                                    }
                                } continueWith: (j := j + 1).
                                ##printLine("dictionaryArgument" . dictionaryArgument).
                                ##printLine("constructionArguments" . constructionArguments).

                                ##printLine("Record type: ". recordType).
                                midBuilder sourcePosition: functionApplication sourcePosition.
                                $recordValue := midBuilder makeRecord: typeToConstruct withElements: constructionArguments.
                                return: recordValue
                            }
                        }.

                        if: isRecordType(typeToConstruct) then: {
                            $recordType := extractRecordType(typeToConstruct).
                            $recordFieldCount := recordType fields size.
                            if: invocationArguments size ~= recordFieldCount then: {
                                printLine("Construction of record is missing arguments. Expected ". recordFieldCount. " arguments instead of". invocationArguments size)
                            }.

                            midBuilder sourcePosition: functionApplication sourcePosition.
                            $recordValue := midBuilder makeRecord: typeToConstruct withElements: invocationArguments.
                            return: recordValue
                        }.

                        printLine("TODO: instantiate objects with numbered fields").
                        abort()
                    }.


                    $functionalValue := extractFunctionFromValue(functional value).
                    $functionalIsMacro := sysmelFunctionIsMacro(functionalValue).

                    if: functionalIsMacro then: {
                        $macroContext := MacroContext#{
                            sourcePosition: functionApplication sourcePosition.
                            environment: environment.
                        }.

                        $macroResult := match: functionalValue ofType: SysmelFunction withPatterns: #{
                            $(SysmelIntrinsicPrimitive)intrinsic : {
                                intrinsic implementation(macroContext . functionApplication arguments)
                            }.
                            $(SysmelCompiledFunction)compiledFunction : {
                                (compiledFunction midIR evaluateWithArguments: [macroContext] -- functionApplication arguments)
                            }.
                            _: {
                                printLine("Unsupported method function kind. " . functionalValue).
                                abort()
                            }
                        }.

                        ##printLine("Macro result". macroResult).
                        if: valueContainsParseTreeFromValue(macroResult value) then: {
                            $macroASTResult := extractParseTreeNodeFromValue(macroResult value).
                            return: (self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: macroASTResult).
                        }
                        else: {
                            printLine("TODO: Put the macro result in a constant.").
                            abort()
                        }

                        
                    }.
                    $invocationArguments := OrderedCollection().
                    $i := 0. while:(i < functionApplication arguments size) do: {
                        $argument := functionApplication arguments at: i.
                        $analyzedArgument := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: argument.
                        invocationArguments add: analyzedArgument.
                    } continueWith:(i := i + 1).

                    midBuilder sourcePosition: functionApplication sourcePosition.
                    return: (midBuilder call: functional withArguments: invocationArguments asArray)
                }.
                $(ParseTreeBinaryOperatorSequenceNode)binopSequence : {
                    if: binopSequence elements size = 1 then: {
                        return: (self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: (binopSequence elements at: 0))
                    }.

                    $!receiver := binopSequence elements at: 0.
                    $i := 1.
                    while: i < binopSequence elements size do: {
                        $selector := binopSequence elements at: i.
                        $operand := binopSequence elements at: i + 1.
                        receiver := ParseTreeNode(ParseTreeMessageSendNode#{
                            sourcePosition: getSourcePositionFromNode(operand).
                            receiver: receiver.
                            selector: selector.
                            arguments: [operand]
                        })
                    } continueWith: (i := i + 2).

                    return: (self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: receiver)
                }.

                ## Sequences, tuples, arrays.
                $(ParseTreeSequenceNode)sequenceNode : {
                    $!result := MidConstantVoid#{
                        sourcePosition: sequenceNode sourcePosition.
                        type: getBasicIntrinsicTypes() voidType
                    }.
                    $!i := 0.
                    while: i < sequenceNode elements size do: {
                        $element := sequenceNode elements at: i.
                        result := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: element.
                    } continueWith: (i := i + 1).
                    return: result
                }.

                ## Association, dictionary
                $(ParseTreeAssociationNode)association : {
                    $key := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: association key.
                    $value := if: association value isNull then: {
                        null
                    } else: {
                        self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: association value.
                    }.
                    midBuilder sourcePosition: association sourcePosition.
                    midBuilder makeAssociationWithKey: key value: value.
                }.
                $(ParseTreeImmutableDictionaryNode)immutableDictionary : {
                    $dictionarySize := immutableDictionary elements size.
                    $associationsArray := Array new: dictionarySize.
                    $i := 0. while: i < dictionarySize do: {
                        $element := immutableDictionary elements at: i.
                        $associationValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: element.
                        associationsArray at: i put: associationValue
                    } continueWith: (i := i + 1).

                    midBuilder sourcePosition: immutableDictionary sourcePosition.
                    midBuilder makeImmutableDictionaryWithAssociations: associationsArray.
                }.

                ## Blocks
                $(ParseTreeLexicalBlockNode)lexicalBlock : {
                    $blockLexicalScope := Environment(LexicalEnvironment#{
                        parent: environment.
                        localSymbols: SymbolHashtable().
                    }).
                    $result := (self analyzeWithEnvironment: blockLexicalScope andCompileClosure: midBuilder withBody: lexicalBlock expression).
                    return: result
                }.

                ## Control flow. Exposed via macros
                $(ParseTreeIfSelectionNode)ifSelection : {
                    $condition := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: ifSelection condition.
                    
                    midBuilder sourcePosition: ifSelection sourcePosition.
                    $branch := midBuilder conditionBranch: condition.

                    $trueBranch := midBuilder makeBranchDestination: branch.
                    $falseBranch := midBuilder makeBranchDestination: branch.
                    $mergeRegion := midBuilder makeBranchMerge: branch.

                    $phiMerge := midBuilder makeMergePhiNode.
                    phiMerge previousControl: mergeRegion.

                    branch trueDestination: trueBranch.
                    branch falseDestination: falseBranch.
                    branch branchMerge: mergeRegion.

                    midBuilder beginWithControlNode: trueBranch.
                    $trueResult := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: ifSelection trueExpression.
                    $truePredecessor := midBuilder currentControlNode.
                    $truePhiValue := midBuilder makePhiNodeValue.
                    
                    truePhiValue sourceValue: trueResult.
                    truePhiValue destinationPhi: phiMerge.
                    truePhiValue previousControl: truePredecessor.

                    $trueBranchSequenceEnd := midBuilder makeBranchSequenceEnd: truePhiValue Into: mergeRegion.

                    midBuilder beginWithControlNode: falseBranch.
                    $falseResult := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: ifSelection falseExpression.
                    $falsePredecessor := midBuilder currentControlNode.
                    $falsePhiValue := midBuilder makePhiNodeValue.

                    falsePhiValue sourceValue: falseResult.
                    falsePhiValue destinationPhi: phiMerge.
                    falsePhiValue previousControl: falsePredecessor.

                    $falseBranchSequenceEnd := midBuilder makeBranchSequenceEnd: falsePhiValue Into: mergeRegion.

                    midBuilder beginWithControlNode: mergeRegion.
                    phiMerge incomingValues: [truePhiValue . falsePhiValue].
                    phiMerge previousControl: mergeRegion.
                    
                    mergeRegion branchNode: branch.
                    mergeRegion incomingEdges: [trueBranchSequenceEnd . falseBranchSequenceEnd].

                    midBuilder beginWithControlNode: phiMerge.

                    return: phiMerge
                }.
                _: {
                    printLine("Unsupported node for compilation. ". ast).
                    abort()
                }
            }.
        }.
]
}
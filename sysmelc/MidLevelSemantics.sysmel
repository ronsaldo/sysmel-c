namespace: SysmelC definition: {
public: [
    SemanticsState
        withSelector: #processDependentType:withEnvironment:forClosureFunction: addMethod: {
            | $(SemanticsState)self $(ParseTreeNode)functionDependentTypeNode $(FunctionAnalysisEnvironment)environment $(MidClosureFunction) closureFunction :: SysmelType |
            $functionDependentType := functionDependentTypeNode extractFunctionalDependentTypeNode.
            $argumentNodes := functionDependentType arguments.
            $processedArguments := OrderedCollection().
            $argumentTypes := OrderedCollection()

            $!i := 0. while: (i < argumentNodes size) do: {
                $argumentBindable := (argumentNodes at: i) extractBindableNameNode.
                
                $!argumentName := null.
                if: argumentBindable isAnonymous not then: {
                    argumentName := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: argumentBindable nameExpression.
                    argumentName := extractSymbolFromValue(argumentName value)
                }.
                $argumentTypeNode := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: argumentBindable typeExpression.
                $argumentType := extractTypeFromValue(argumentTypeNode value).
                argumentTypes add: argumentType.

                $midType := MidConstantType(argumentType).
                $midArgument := MidArgument#{
                    owner: closureFunction.
                    index: i asUInt32.
                    name: argumentName.
                    typeExpression: midType
                }.

                if: argumentBindable isAnonymous not then: {
                    Environment(environment) addLocalSymbol: argumentName withValue:
                        TypedValue(Value(SysmelMidValue(midArgument)). argumentType)
                }.

                processedArguments add: midArgument.
            } continueWith: (i := i + 1).

            closureFunction arguments: processedArguments asArray.
            $resultTypeNode := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: functionDependentType resultTypeExpression.
            $resultType := extractTypeFromValue(resultTypeNode value).

            $functionType := SysmelType(SysmelSimpleFunctionType#{
                common: SysmelTypeCommon#{

                }.
                supertype: getBasicIntrinsicTypes() function.
                isCompileTimePure: false.
                isVariadic: false.
                argumentTypes: argumentTypes asArray.
                resultType: resultType.
            }).

            closureFunction type: functionType.
            functionType
        };
        withSelector: #analyzeWithEnvironment:andCompileClosure: addMethod: {
        | $(SemanticsState)self $(Environment)environment $(ParseTreeFunctionNode)ast :: TypedValue |

            $midFunction := MidClosureFunction#{
                sourcePosition: ast sourcePosition.
                name: ast name.
                captures: [].
                arguments: []
            }.

            $interpretedFunction := SysmelCompiledFunction#{
                midIR: midFunction.
            }.

            $analysisEnvironment := FunctionAnalysisEnvironment#{
                parent: environment.
                localSymbols: SymbolHashtable().
            }.

            $functionType := self processDependentType: ast functionDependentType withEnvironment: analysisEnvironment forClosureFunction: midFunction.

            if: ast isAnonymous not then: {
                interpretedFunction name: ast name.
                environment addLocalSymbol: ast name withValue: TypedValue(Value(SysmelFunctionValue(SysmelFunction(interpretedFunction))). functionType).
            }.

            $midBuilder := midFunction makeBuilder.
            $bodyResult := self analyzeWithEnvironment: Environment(analysisEnvironment)
                andCompileClosure: midBuilder withBody: ast bodyExpression.
            midBuilder returnValue: bodyResult.
            midBuilder finish.

            $functionValue := TypedValue(Value(SysmelFunctionValue(SysmelFunction(interpretedFunction))). functionType).
        };
        withSelector: #analyzeWithEnvironment:andCompileClosure:withBody: addMethod: {
            | $(SemanticsState)self $(Environment)environment $(MidFunctionBuilder)midBuilder $(ParseTreeNode)ast :: MidValue |
            match: ast ofType: ParseTreeNode withPatterns: #{
                ## Literals.
                $(ParseTreeLiteralIntegerNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantInteger: literal value.
                }.
                $(ParseTreeLiteralCharacterNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantCharacter: literal value.
                }.
                #*
        }.
        Record: ParseTreeLiteralFloatNode withFields: #{
            sourcePosition: SourcePosition.
            value: Float.
        }.
        Record: ParseTreeLiteralStringNode withFields: #{
            sourcePosition: SourcePosition.
            value: String.
        }.
        Record: ParseTreeLiteralSymbolNode withFields: #{
            sourcePosition: SourcePosition.
            value: Symbol.
        }.*#
                _: {
                    printLine("Unsupported node for compilation. ". ast).
                    abort()
                }
            }.
        }.
]
}
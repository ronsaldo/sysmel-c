namespace: SysmelC definition: {
public: [
    SemanticsState
        withSelector: #processDependentType:withEnvironment:forClosureFunction: addMethod: {
            | $(SemanticsState)self $(ParseTreeNode)functionDependentTypeNode $(FunctionAnalysisEnvironment)environment $(MidClosureFunction) closureFunction :: SysmelType |
            $functionDependentType := functionDependentTypeNode extractFunctionalDependentTypeNode.
            $argumentNodes := functionDependentType arguments.
            $processedArguments := OrderedCollection().
            $argumentTypes := OrderedCollection().

            $!i := 0. while: (i < argumentNodes size) do: {
                $argumentBindable := (argumentNodes at: i) extractBindableNameNode.
                
                $!argumentName := null.
                if: argumentBindable isAnonymous not then: {
                    argumentName := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: argumentBindable nameExpression.
                    argumentName := extractSymbolFromValue(argumentName value)
                }.
                $argumentTypeNode := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: argumentBindable typeExpression.
                $argumentType := extractTypeFromValue(argumentTypeNode value).
                argumentTypes add: argumentType.

                $midType := MidConstantType#{
                    value: argumentType
                }.
                $midArgument := MidArgument#{
                    owner: closureFunction.
                    index: i asUInt32.
                    name: argumentName.
                    typeExpression: midType.
                    type: argumentType
                }.

                if: argumentBindable isAnonymous not then: {
                    Environment(environment) addLocalSymbol: argumentName withValue:
                        TypedValue(Value(SysmelMidValue(midArgument)). argumentType)
                }.

                processedArguments add: midArgument.
            } continueWith: (i := i + 1).

            closureFunction arguments: processedArguments asArray.
            $resultTypeNode := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: functionDependentType resultTypeExpression.
            $resultType := if: resultTypeNode isNull then: {
                getBasicIntrinsicTypes() gradual
            }
            else: {
                extractTypeFromValue(resultTypeNode value)
            }.

            $functionType := SysmelType(SysmelSimpleFunctionType#{
                common: SysmelTypeCommon#{

                }.
                supertype: getBasicIntrinsicTypes() function.
                isCompileTimePure: false.
                isVariadic: false.
                argumentTypes: argumentTypes asArray.
                resultType: resultType.
            }).

            closureFunction type: functionType.
            functionType
        };
        withSelector: #analyzeWithEnvironment:andCompileClosure: addMethod: {
        | $(SemanticsState)self $(Environment)environment $(ParseTreeFunctionNode)ast :: TypedValue |

            $midFunction := MidClosureFunction#{
                sourcePosition: ast sourcePosition.
                name: ast name.
                captures: [].
                arguments: [].
                isMacro: false.
            }.

            $interpretedFunction := SysmelCompiledFunction#{
                midIR: midFunction.
                isMacro: false.
            }.

            $analysisEnvironment := FunctionAnalysisEnvironment#{
                parent: environment.
                localSymbols: SymbolHashtable().
            }.

            $functionType := self processDependentType: ast functionDependentType withEnvironment: analysisEnvironment forClosureFunction: midFunction.
            if: ast isAnonymous not then: {
                interpretedFunction name: ast name.
                environment addLocalSymbol: ast name withValue: TypedValue(Value(SysmelFunctionValue(SysmelFunction(interpretedFunction))). functionType).
            }.

            $midBuilder := midFunction makeBuilder.
            $bodyResult := self analyzeWithEnvironment: Environment(analysisEnvironment)
                andCompileClosure: midBuilder withBody: ast bodyExpression.
            midBuilder returnValue: bodyResult.
            midBuilder finish.

            $functionValue := TypedValue(Value(SysmelFunctionValue(SysmelFunction(interpretedFunction))). functionType).
        };
        withSelector: #analyzeMessageSendWithReceiver:selector:arguments:environment:inCompileClosure:sourcePosition: addMethod: {
            |$(SemanticsState)self $(MidValue)receiverMidValue $(ParseTreeNode)selector $(Array)arguments $(Environment)environment $(MidFunctionBuilder)midBuilder $(SourcePosition)sourcePosition :: MidValue |
                $selectorValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: selector.
                $selectorSymbolValue := selectorValue value.

                $!receiverValue := receiverMidValue.
                $!receiverType := receiverValue type.

                $!method := receiverType lookupSelector: selectorSymbolValue.
                if: (method value isInvalidErrorValue) && (isReferenceType(receiverType)) then: {
                    midBuilder sourcePosition: sourcePosition.
                    $newReceiverType := receiverType getBaseType.
                    $loaded := midBuilder load: newReceiverType from: receiverValue.
                    
                    receiverValue := loaded.
                    receiverType := newReceiverType.
                    method := receiverType lookupSelector: selectorSymbolValue.
                }.
                
                if: method value isInvalidErrorValue then: {

                    match: receiverType ofType: SysmelType withPatterns: #{
                        $(SysmelTupleAndRecordType)tupleAndRecord : {
                            ##printLine("tupleAndRecord ". arguments size).
                            if: arguments size = 0 then: {
                                $fieldIndex := findIndexOfRecordFieldWithName(tupleAndRecord. selectorSymbolValue).
                                if: fieldIndex >= 0 then: {
                                    ## Implicit getter.
                                    $fieldType := tupleAndRecord fields at: fieldIndex.
                                    ##printLine("Emit instruction for getting field ". fieldIndex).
                                    ##printLine(receiverValue)
                                    $extractInstruction := midBuilder fromComposite: receiverValue extractAtIndex: fieldIndex withType: fieldType.
                                    return: extractInstruction
                                }
                            }.
                            if: arguments size = 1 then: {
                                
                                $selectorWithoutTrailingColon := selectorSymbolValue withoutTrailingColon.
                                $fieldIndex := findIndexOfRecordFieldWithName(tupleAndRecord. selectorWithoutTrailingColon).
                                ##printLine("Setter ". selectorWithoutTrailingColon . " fieldIndex ". fieldIndex).
                                if: fieldIndex >= 0 then: {
                                    ## Implicit setter
                                    $setterValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: (arguments at: 0).
                                    $insertInstruction := midBuilder inComposite: receiverValue insertValue: setterValue atIndex: fieldIndex.
                                    return: insertInstruction
                                }
                            }.
                        }.
                        $(SysmelClassType)class : {
                            ##printLine("tupleAndRecord ". arguments size).
                            if: arguments size = 0 then: {
                                $fieldIndex := findIndexOfClassFieldWithName(class. selectorSymbolValue).
                                if: fieldIndex >= 0 then: {
                                    ## Implicit getter.
                                    $fieldType := class getFieldTypeAtIndex: fieldIndex.
                                    ##printLine("Emit instruction for getting field ". fieldIndex).
                                    $extractInstruction := midBuilder fromComposite: receiverValue extractAtIndex: fieldIndex withType: fieldType.
                                    return: extractInstruction
                                }
                            }.
                            if: arguments size = 1 then: {
                                
                                $selectorWithoutTrailingColon := selectorSymbolValue withoutTrailingColon.
                                $fieldIndex := findIndexOfClassFieldWithName(class. selectorWithoutTrailingColon).
                                ##printLine("Setter ". selectorWithoutTrailingColon . " fieldIndex ". fieldIndex).
                                if: fieldIndex >= 0 then: {
                                    ## Implicit setter
                                    $setterValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: (arguments at: 0).
                                    $insertInstruction := midBuilder inComposite: receiverValue insertValue: setterValue atIndex: fieldIndex.
                                    return: insertInstruction
                                }
                            }.
                        }.
                        _: {
                            ## Nothing required here. 
                        }
                    }.
                }.

                $invocationArguments := OrderedCollection().
                $!i := 0. while:(i < arguments size) do: {
                    $argument := arguments at: i.
                    $analyzedArgument := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: argument.
                    invocationArguments add: analyzedArgument.
                } continueWith:(i := i + 1).

                midBuilder sourcePosition: sourcePosition.
                return: (midBuilder send: selectorValue to: receiverValue withArguments: invocationArguments asArray)
        };
        withSelector: #analyzeWithEnvironment:andCompileClosure:withBody: addMethod: {
            | $(SemanticsState)self $(Environment)environment $(MidFunctionBuilder)midBuilder $(ParseTreeNode)ast :: MidValue |
            match: ast ofType: ParseTreeNode withPatterns: #{
                $(ParseTreeNullNode)nullNode : {
                    MidConstantNull#{
                        sourcePosition: nullNode sourcePosition.
                        type: getBasicIntrinsicTypes() null
                    }
                }.
                
                ## Errors.
                $(ParseTreeErrorNode)errorNode : {
                    errorNode sourcePosition printFormatted.
                    printLine("Error ". errorNode errorMessage).
                    abort()
                }.
                $(ParseTreeAssertNode)assertNode : {
                    $condition := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: assertNode condition.

                    midBuilder sourcePosition: assertNode sourcePosition.
                    midBuilder assert: condition withDescription: assertNode sourcePosition getText.
                }.

                ## Literals.
                $(ParseTreeLiteralBooleanNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantBoolean: literal value.
                }.
                $(ParseTreeLiteralIntegerNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantInteger: literal value.
                }.
                $(ParseTreeLiteralCharacterNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantCharacter: literal value.
                }.
                $(ParseTreeLiteralFloatNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantFloat: literal value.
                }.
                $(ParseTreeLiteralStringNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantString: literal value.
                }.
                $(ParseTreeLiteralSymbolNode)literal : {
                    midBuilder sourcePosition: literal sourcePosition.
                    midBuilder constantSymbol: literal value.
                }.
                
                ## Identifiers
                $(ParseTreeIdentifierReferenceNode)identifier : {
                    $value := environment lookupSymbolRecursively: identifier value.
                    if: value isInvalidErrorValue then: {
                        printLine(value getInvalidErrorValueMessage).
                        printLine("ParseTreeIdentifierReferenceNode").
                        abort()
                    }.

                    if: value value isMidValue then: {
                        return: value value getMidValue 
                    }.

                    if: isFunctionValue(value value) then: {
                        $functionValue := extractFunctionFromValue(value value).

                        match: functionValue ofType: SysmelFunction withPatterns: #{
                            $(SysmelIntrinsicPrimitive)intrinsicPrimitive : {
                                return: MidIntrinsicFunction#{
                                    type: value type.
                                    name: intrinsicPrimitive name.
                                    primitive: intrinsicPrimitive implementation.
                                    isMacro: intrinsicPrimitive isMacro.
                                }
                            }.
                            $(SysmelCompiledFunction)compiledFunction : {
                                if: compiledFunction midIR isNotNull then: {
                                    return: compiledFunction midIR
                                }
                            }.
                        }
                    }.
                    midBuilder sourcePosition: identifier sourcePosition.
                    ##printLine("constant value ". value value).
                    ##printLine("constant type ". value type).
                    ##printLine("constant typed ". value).
                    return: (midBuilder constantValue: value).
                }.
    
                ## Messages and applications
                $(ParseTreeMessageSendNode)messageSend : {
                    $receiver := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: messageSend receiver.
                    $selectorValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: messageSend selector.
                    $selectorSymbolValue := selectorValue value.

                    ## TODO: Use a macro for this.
                    if: messageSend arguments size == 1 then: {
                        if: selectorSymbolValue == #&& then: {
                            $shortCircuit := ParseTreeIfSelectionNode#{
                                sourcePosition: messageSend sourcePosition.
                                condition: messageSend receiver.
                                trueExpression: (messageSend arguments at: 0).
                                falseExpression: (ParseTreeNode(ParseTreeLiteralBooleanNode#{
                                    sourcePosition: messageSend sourcePosition.
                                    value: false
                                })).
                            }.
                            return: (self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: ParseTreeNode(shortCircuit)).
                        }.

                        if: selectorSymbolValue == #|| then: {
                            $shortCircuit := ParseTreeIfSelectionNode#{
                                sourcePosition: messageSend sourcePosition.
                                condition: messageSend receiver.
                                trueExpression: (ParseTreeNode(ParseTreeLiteralBooleanNode#{
                                    sourcePosition: messageSend sourcePosition.
                                    value: true
                                })).
                                falseExpression: (messageSend arguments at: 0).
                            }.
                            return: (self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: (ParseTreeNode(shortCircuit))).
                        }.
                    }.

                    return: (self analyzeMessageSendWithReceiver: receiver selector: messageSend selector arguments: messageSend arguments environment: environment inCompileClosure: midBuilder sourcePosition: messageSend sourcePosition)
                }.
                $(ParseTreeMessageCascadeNode)messageCascade : {
                    $receiver := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: messageCascade receiver.
                    $!result := receiver.
                    $!i := 0. while: (i < messageCascade cascadedMessages size) do: {
                        $(ParseTreeCascadedMessageNode)cascaded := messageCascade cascadedMessages at: i.
                        result := (self analyzeMessageSendWithReceiver: receiver selector: cascaded selector arguments: cascaded arguments environment: environment inCompileClosure: midBuilder sourcePosition: cascaded sourcePosition)
                    } continueWith: (i := i + 1).
                    return: result
                }.
                $(ParseTreeCascadedMessageNode)cascadedMessage : {
                    cascadedMessage sourcePosition printFormatted.
                    printLine("A cascaded message must be a part of a cascade.").
                }.
                $(ParseTreeFunctionApplicationNode)functionApplication : {
                    $functional := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: functionApplication functional.
                    ## Is this a type constructor invocation?
                    ##printLine().
                    ##functionApplication sourcePosition printFormatted.
                    ##printLine("functional ". functional).
                    ##printLine().

                    if: functional isFunctionalValue not && functional isConstant && isTypeValue(functional value) then: {
                        $typeToConstruct := extractTypeFromValue(functional value).
                        ##printLine("typeToConstruct: ". typeToConstruct).

                        $argumentCount := functionApplication arguments size.
                        $invocationArguments := Array new: argumentCount.
                        $!i := 0. while: (i < argumentCount) do: {
                            $argumentValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: (functionApplication arguments at: i).
                            invocationArguments at: i put: argumentValue
                        } continueWith: (i := i + 1).

                        if: (invocationArguments size = 1) && (invocationArguments at: 0) isImmutableDictionary then: {
                            if: isRecordType(typeToConstruct) then: {
                                $dictionaryArgument := invocationArguments at: 0.
                                $recordType := extractRecordType(typeToConstruct).
                                $constructionArguments := Array new: recordType fields size.

                                $associations := dictionaryArgument associations.
                                $!j := 0. while: (j < associations size) do: {
                                    $assoc := associations at: j.
                                    $keySymbol := assoc key asSymbol.
                                    ##printLine(j. " keySymbol ". keySymbol).
                                    $fieldIndex := findIndexOfRecordFieldWithName(recordType. keySymbol).
                                    if: (fieldIndex < 0) || (fieldIndex >= constructionArguments size) then: {
                                        functionApplication sourcePosition printFormatted.
                                        printLine("Invalid field index [". fieldIndex. "] for construction of a ". recordType common name).
                                        abort()
                                    } else: {
                                        constructionArguments at: fieldIndex put: assoc value
                                    }
                                } continueWith: (j := j + 1).
                                ##printLine("dictionaryArgument" . dictionaryArgument).
                                ##printLine("constructionArguments" . constructionArguments).

                                ##printLine("Record type: ". recordType).
                                midBuilder sourcePosition: functionApplication sourcePosition.
                                $recordValue := midBuilder makeRecord: typeToConstruct withElements: constructionArguments.
                                return: recordValue
                            }.

                            if: isClassType(typeToConstruct) then: {
                                $dictionaryArgument := invocationArguments at: 0.
                                $classType := extractClassType(typeToConstruct).
                                $constructionArguments := Array new: classType totalFieldCount.

                                $associations := dictionaryArgument associations.
                                $!j := 0. while: (j < associations size) do: {
                                    $assoc := associations at: j.
                                    $keySymbol := assoc key asSymbol.
                                    ##printLine(j. " keySymbol ". keySymbol).
                                    $fieldIndex := findIndexOfClassFieldWithName(classType. keySymbol).
                                    if: (fieldIndex < 0) || (fieldIndex >= constructionArguments size) then: {
                                        functionApplication sourcePosition printFormatted.
                                        printLine("Invalid field index [". fieldIndex. "] for construction of a ". classType common name).
                                        abort()
                                    } else: {
                                        constructionArguments at: fieldIndex put: assoc value
                                    }
                                } continueWith: (j := j + 1).
                                ##printLine("dictionaryArgument" . dictionaryArgument).
                                ##printLine("constructionArguments" . constructionArguments).

                                ##printLine("Record type: ". recordType).
                                midBuilder sourcePosition: functionApplication sourcePosition.
                                $recordValue := midBuilder makeObject: typeToConstruct withElements: constructionArguments.
                                return: recordValue
                            }.
                        }.

                        if: isRecordType(typeToConstruct) then: {
                            $recordType := extractRecordType(typeToConstruct).
                            $recordFieldCount := recordType fields size.
                            if: (invocationArguments size ~= recordFieldCount) && (invocationArguments size ~= 0) then: {
                                printLine("Warning: Construction of record is missing arguments. Expected ". recordFieldCount. " arguments instead of". invocationArguments size).
                                printLine("typeToConstruct". typeToConstruct).
                            }.

                            midBuilder sourcePosition: functionApplication sourcePosition.
                            $recordValue := midBuilder makeRecord: typeToConstruct withElements: invocationArguments.
                            return: recordValue
                        }.

                        if: isSumType(typeToConstruct) then: {
                            $sumType := extractSumType(typeToConstruct).

                            if: invocationArguments size ~= 1 then: {
                                printLine("Sum type injection requires a single argument.").
                                abort().
                            }.

                            $injectionArgument := invocationArguments at: 0.
                            $injectionType := injectionArgument type.
                            $injectionIndex := findIndexOfSumTypeAlternative(sumType. injectionType).
                            if: injectionIndex < 0 then: {
                                printLine("Cannot perform sum injection of a non-alternative type.").
                                abort()
                            }.

                            $injectedSum := midBuilder inject: injectionArgument withSumType: SysmelType(sumType) atIndex: MidConstantInteger#{value: injectionIndex}.
                            ##printLine("injectedSum ". injectedSum).
                            return: injectedSum
                        }.

                        functionApplication sourcePosition printFormatted.
                        printLine("TODO: instantiate objects with numbered fields").
                        printLine(typeToConstruct getCommonSection name).
                        abort()
                    }.

                    if: functional isFunctionalValue && functional isMacro then: {
                        $macroContext := MacroContext#{
                            sourcePosition: functionApplication sourcePosition.
                            environment: environment.
                        }.

                        $macroResult := functional invokeAsMacroWithContext: macroContext andArguments: functionApplication arguments.

                        ##printLine("Macro result ". macroResult).
                        if: valueContainsParseTreeFromValue(macroResult value) then: {
                            $macroASTResult := extractParseTreeNodeFromValue(macroResult value).
                            ##printLine("Macro ast result". macroASTResult).
                            return: (self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: macroASTResult).
                        }
                        else: {
                            printLine("TODO: Put the macro result in a constant.").
                            abort()
                        }
                    }.

                    $invocationArguments := OrderedCollection().
                    $!i := 0. while:(i < functionApplication arguments size) do: {
                        $argument := functionApplication arguments at: i.
                        $analyzedArgument := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: argument.
                        invocationArguments add: analyzedArgument.
                    } continueWith:(i := i + 1).

                    midBuilder sourcePosition: functionApplication sourcePosition.
                    return: (midBuilder call: functional withArguments: invocationArguments asArray)
                }.
                $(ParseTreeBinaryOperatorSequenceNode)binopSequence : {
                    if: binopSequence elements size = 1 then: {
                        return: (self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: (binopSequence elements at: 0))
                    }.

                    $!receiver := binopSequence elements at: 0.
                    $!i := 1.
                    while: i < binopSequence elements size do: {
                        $selector := binopSequence elements at: i.
                        $operand := binopSequence elements at: i + 1.
                        receiver := ParseTreeNode(ParseTreeMessageSendNode#{
                            sourcePosition: getSourcePositionFromNode(operand).
                            receiver: receiver.
                            selector: selector.
                            arguments: [operand]
                        })
                    } continueWith: (i := i + 2).

                    return: (self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: receiver)
                }.

                ## Sequences, tuples, arrays.
                $(ParseTreeSequenceNode)sequenceNode : {
                    $!result := MidConstantVoid#{
                        sourcePosition: sequenceNode sourcePosition.
                        type: getBasicIntrinsicTypes() voidType
                    }.
                    $!i := 0.
                    while: i < sequenceNode elements size do: {
                        $element := sequenceNode elements at: i.
                        result := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: element.
                    } continueWith: (i := i + 1).
                    return: result
                }.
                $(ParseTreeTupleNode)tupleNode : {
                    $elementCount := tupleNode elements size.
                    $midElements := Array new: elementCount.
                    $!i := 0. while: (i < elementCount) do: {
                        $midElement := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: (tupleNode elements at: i).
                        midElements at: i put: midElement.
                    } continueWith:(i := i + 1).
                    
                    midBuilder sourcePosition: tupleNode sourcePosition.
                    $midTuple := midBuilder makeTupleWithElements: midElements.
                    return: midTuple
                }.
                $(ParseTreeArrayNode)arrayNode : {
                    $elementCount := arrayNode elements size.
                    $midElements := Array new: elementCount.
                    $!i := 0. while: (i < elementCount) do: {
                        $midElement := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: (arrayNode elements at: i).
                        midElements at: i put: midElement.
                    } continueWith:(i := i + 1).
                    
                    midBuilder sourcePosition: arrayNode sourcePosition.
                    $midArray := midBuilder makeArrayWithElements: midElements.
                    return: midArray
                }.
                $(ParseTreeByteArrayNode)byteArrayNode : {
                    printLine("TODO: Byte array node").
                    abort()
                }.

                ## Association, dictionary
                $(ParseTreeAssociationNode)association : {
                    $key := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: association key.
                    $value := if: association value isNull then: {
                        null
                    } else: {
                        self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: association value.
                    }.
                    midBuilder sourcePosition: association sourcePosition.
                    midBuilder makeAssociationWithKey: key value: value.
                }.
                $(ParseTreeImmutableDictionaryNode)immutableDictionary : {
                    $dictionarySize := immutableDictionary elements size.
                    $associationsArray := Array new: dictionarySize.
                    $!i := 0. while: i < dictionarySize do: {
                        $element := immutableDictionary elements at: i.
                        $associationValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: element.
                        associationsArray at: i put: associationValue
                    } continueWith: (i := i + 1).

                    midBuilder sourcePosition: immutableDictionary sourcePosition.
                    midBuilder makeImmutableDictionaryWithAssociations: associationsArray.
                }.
                ## Blocks
                $(ParseTreeBlockClosureNode)blockClosure : {
                    printLine("TODO: ParseTreeBlockClosureNode").
                    abort()
                }.
                $(ParseTreeLexicalBlockNode)lexicalBlock : {
                    $blockLexicalScope := Environment(LexicalEnvironment#{
                        parent: environment.
                        localSymbols: SymbolHashtable().
                    }).
                    $result := (self analyzeWithEnvironment: blockLexicalScope andCompileClosure: midBuilder withBody: lexicalBlock expression).
                    return: result
                }.

                ## Binding and pattern matching.
                $(ParseTreeFunctionalDependentTypeNode)functionalDependentTypeNode : {
                    printLine("TODO: ParseTreeFunctionalDependentTypeNode").
                    abort()
                }.
                $(ParseTreeBindableNameNode)bindableNode : {
                    printLine("TODO: ParseTreeBindableNameNode").
                    abort()
                }.
                $(ParseTreeAssignmentNode)assignmentNode : {
                    $store := assignmentNode store.
                    $value := assignmentNode value.
                    match: store ofType: ParseTreeNode withPatterns: #{
                        $(ParseTreeBindableNameNode)bindable : {
                            $!name := null.
                            if: bindable isAnonymous not then: {
                                $nameValue := self analyzeAndEvaluateWithEnvironment: environment script: bindable nameExpression.
                                name := extractSymbolFromValue(nameValue value)
                            }.

                            if: bindable hasPostTypeExpression && bindable typeExpression isFunctionalDependentTypeNode then: {
                                $functionNode := ParseTreeFunctionNode#{
                                    sourcePosition: getSourcePositionFromNode(ast).
                                    functionDependentType: bindable typeExpression.
                                    bodyExpression: value.
                                    isAnonymous: bindable isAnonymous.
                                }.
                                if: bindable isAnonymous not then: {
                                    functionNode name: name.
                                }.

                                ## TODO: make a proper closure.
                                return: (self analyzeWithEnvironment: environment andCompileClosure: functionNode)
                            }.

                            $initialValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: value.
                            ##printLine("initialValue: ". initialValue).
                            ##printLine("initialValue type: ". initialValue type).
                            ##printLine("initialValue type: ". initialValue type).
                            if: bindable isMutable then: {
                                $alloca := midBuilder alloca: initialValue type.
                                midBuilder store: initialValue in: alloca.
                                environment addLocalSymbol: name withValue: TypedValue(Value(SysmelMidValue(alloca)). alloca type)
                            } else: {
                                environment addLocalSymbol: name withValue: TypedValue(Value(SysmelMidValue(initialValue)). initialValue type)
                            }.
                            initialValue
                        }.
                        $(ParseTreeIdentifierReferenceNode)identifierReference : {
                            $binding := environment lookupSymbolRecursively: identifierReference value.
                            if: binding isNull then: {
                                printLine("Failed to find binding for: ". identifierReference value).
                                abort()
                            }.

                            if: isReferenceType(binding type) then: {
                                if: binding value isMidValue then:
                                {
                                    $reference := binding value getMidValue.
                                    $newValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: value.
                                    midBuilder sourcePosition: assignmentNode sourcePosition.
                                    midBuilder store: newValue in: reference.
                                    return: newValue
                                }
                            }.
                            identifierReference sourcePosition printFormatted.
                            printLine("binding ". binding type).
                            printLine("Invalid assignment.").
                            abort()
                        }.
                        _: {
                            ## Turn the assignment into a message send.
                            $selectorLiteral := ParseTreeNode(ParseTreeLiteralSymbolNode#{
                                sourcePosition: ast sourcePosition.
                                value: #":="
                            }).
                            $messageSend := ParseTreeNode(ParseTreeMessageSendNode#{
                                sourcePosition: ast sourcePosition.
                                receiver: store.
                                selector: selectorLiteral.
                                arguments: [value]
                            }).
                            self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: messageSend
                        }
                    }.

                }.

                ## Closure and functions
                $(ParseTreeFunctionNode)functionNode : {
                    printLine("TODO: ParseTreeFunctionNode").
                    abort()
                }.

                ## Control flow. Exposed via macros
                $(ParseTreeIfSelectionNode)ifSelection : {
                    $condition := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: ifSelection condition.
                    
                    midBuilder sourcePosition: ifSelection sourcePosition.
                    $branch := midBuilder conditionBranch: condition.

                    $trueBranch := midBuilder makeBranchDestination: branch.
                    $falseBranch := midBuilder makeBranchDestination: branch.
                    $mergeRegion := midBuilder makeBranchMerge: branch.

                    $phiMerge := midBuilder makeMergePhiNode.
                    phiMerge previousControl: mergeRegion.

                    branch trueDestination: trueBranch.
                    branch falseDestination: falseBranch.
                    branch branchMerge: mergeRegion.

                    midBuilder beginWithControlNode: trueBranch.
                    $trueResult := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: ifSelection trueExpression.
                    $truePredecessor := midBuilder currentControlNode.
                    $truePhiValue := midBuilder makePhiNodeValue.
                    
                    truePhiValue sourceValue: trueResult.
                    truePhiValue destinationPhi: phiMerge.
                    truePhiValue previousControl: truePredecessor.

                    $trueBranchSequenceEnd := midBuilder makeBranchSequenceEnd: truePhiValue Into: mergeRegion.

                    midBuilder beginWithControlNode: falseBranch.
                    $falseResult := if: ifSelection falseExpression isNotNull then: {
                        self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: ifSelection falseExpression.
                    } else: {
                        MidConstantVoid#{}
                    }.
                    $falsePredecessor := midBuilder currentControlNode.
                    $falsePhiValue := midBuilder makePhiNodeValue.

                    falsePhiValue sourceValue: falseResult.
                    falsePhiValue destinationPhi: phiMerge.
                    falsePhiValue previousControl: falsePredecessor.

                    $falseBranchSequenceEnd := midBuilder makeBranchSequenceEnd: falsePhiValue Into: mergeRegion.

                    midBuilder beginWithControlNode: mergeRegion.
                    phiMerge incomingValues: [truePhiValue . falsePhiValue].
                    phiMerge previousControl: mergeRegion.
                    
                    mergeRegion branchNode: branch.
                    mergeRegion incomingEdges: [trueBranchSequenceEnd . falseBranchSequenceEnd].

                    midBuilder beginWithControlNode: phiMerge.

                    return: phiMerge
                }.
                $(ParseTreeSwitchNode)switchNode : {
                    $switchValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: switchNode value.

                    $switchCases := switchNode cases.
                    $!casesValues := OrderedCollection().
                    $!casesActions := OrderedCollection().
                    $!defaultAction := null.
                    match: switchCases ofType: ParseTreeNode withPatterns: #{
                        $(ParseTreeImmutableDictionaryNode)caseDictionary : {
                            $dictionaryElements := caseDictionary elements.
                            $elementCount := dictionaryElements size.
                            $!i := 0. while: (i < elementCount) do: {
                                $caseAssociation := (dictionaryElements at: i) extractAssociationNode.
                                $caseValue := self analyzeAndEvaluateWithEnvironment: environment script: caseAssociation key.
                                match: caseValue value ofType: Value withPatterns: #{
                                    $(IntegerValue)integerValue : {
                                        $caseIntegerValue := integerValue value.
                                        casesValues add: MidConstantInteger#{
                                            value: caseIntegerValue.
                                            type: getBasicIntrinsicTypes() integer.
                                        }.
                                        casesActions add: caseAssociation value.
                                    }.
                                    $(SymbolValue)symbolValue : {
                                        defaultAction := caseAssociation value.
                                    }.
                            }.
                            } continueWith: (i := i + 1).
                        }.
                        _: {
                            printLine("Cases must be specified through an immutable dictionary.").
                            abort()
                        }
                    }.

                    ##printLine(switchValue).
                    ##printLine("Case value ". casesValues).
                    ##printLine("Case actions ". casesActions).
                    ##printLine("Default action ". defaultAction).

                    ## Make the case control flow
                    $switchBranch := midBuilder switchBranch: switchValue caseValues: casesValues asArray.

                    $caseCount := casesValues size.
                    $branchDestinations := Array new: caseCount.
                    ##printLine("Make switch destinations.")
                    $!i := 0. while: (i < caseCount) do: {
                        branchDestinations at: i put: (midBuilder makeBranchDestination: switchBranch)
                    } continueWith: (i := i + 1).
                    switchBranch caseDestinations: branchDestinations.
                    
                    $defaultDestination := midBuilder makeBranchDestination: switchBranch.
                    switchBranch defaultDestination: defaultDestination.
                    $switchMerge := midBuilder makeSwitchMerge: switchBranch.
                    
                    $phiMerge := midBuilder makeMergePhiNode.
                    phiMerge previousControl: switchMerge.

                    $mergePredecessors := OrderedCollection().
                    $phiValues := OrderedCollection().

                    ## Compile the case destinations
                    ##printLine("Compile the case destinations").
                    $!i := 0. while: (i < caseCount) do: {
                        midBuilder beginWithControlNode: (branchDestinations at: i).
                        midBuilder sourcePosition: switchNode sourcePosition.

                        $caseAction := casesActions at: i.
                        $caseValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: caseAction.

                        $branchPhiValue := midBuilder makePhiNodeValue.
                        branchPhiValue sourceValue: caseValue.
                        branchPhiValue destinationPhi: phiMerge.
                        branchPhiValue previousControl: midBuilder currentControlNode.
                        phiValues add: branchPhiValue.

                        $switchBranchPredecessor := midBuilder makeBranchSequenceEnd: branchPhiValue Into: switchMerge.
                        mergePredecessors add: switchBranchPredecessor.
                    } continueWith: (i := i + 1).

                    ##printLine("Compile default").
                    midBuilder beginWithControlNode: defaultDestination.
                    midBuilder sourcePosition: switchNode sourcePosition.

                    $defaultValue := if: defaultAction isNotNull then: {
                        self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: defaultAction
                    } else: {
                        MidConstantVoid#{}
                    }.

                    $defaultPhiValue := midBuilder makePhiNodeValue.
                    defaultPhiValue sourceValue: defaultValue.
                    defaultPhiValue destinationPhi: phiMerge.
                    defaultPhiValue previousControl: midBuilder currentControlNode.
                    phiValues add: defaultPhiValue.

                    $defaultBranchPredecessor := midBuilder makeBranchSequenceEnd: defaultPhiValue Into: switchMerge.
                    mergePredecessors add: defaultBranchPredecessor.

                    ##printLine("Merge switch.").
                    midBuilder beginWithControlNode: switchMerge.
                    midBuilder sourcePosition: switchNode sourcePosition.

                    phiMerge incomingValues: phiValues asArray.
                    phiMerge previousControl: switchMerge.
                    
                    ##printLine("Merge predecessors.". mergePredecessors asArray).
                    switchMerge predecessors: mergePredecessors asArray.
                    midBuilder beginWithControlNode: phiMerge.

                    return: phiMerge
                    
                }.
                $(ParseTreeSwitchPatternMatchingNode)switchPatternNode : {
                    $switchSumValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: switchPatternNode value.
                    $sumTypeValue := self analyzeAndEvaluateWithEnvironment: environment script: switchPatternNode valueSumType.
                    $sumType := match: extractTypeFromValue(sumTypeValue value) ofType: SysmelType withPatterns: #{
                        $(SysmelSumType) sumtype : sumtype.
                        _: {
                            printLine("Expected a sum type").
                        }
                    }.
                    
                    $!casesAlternativeIndex := OrderedCollection().
                    $!casesAlternativeTypes := OrderedCollection().
                    $!casesActions := OrderedCollection().
                    $!casesBindables := OrderedCollection().
                    $!defaultAction := null.

                    match: switchPatternNode cases ofType: ParseTreeNode withPatterns: #{
                        $(ParseTreeImmutableDictionaryNode)caseDictionary : {
                            $dictionaryElements := caseDictionary elements.
                            $elementCount := dictionaryElements size.
                            $!i := 0. while: (i < elementCount) do: {
                                $caseAssociation := (dictionaryElements at: i) extractAssociationNode.
                                ##printLine("caseAssociation key ". caseAssociation key)
                                match: caseAssociation key ofType: ParseTreeNode withPatterns: #{
                                    $(ParseTreeBindableNameNode)bindable : {
                                        $bindableType := self analyzeAndEvaluateWithEnvironment: environment script: bindable typeExpression.
                                        $bindableTypeValue := bindableType value getTypeValue.
                                        ##printLine("bindableType ". bindableTypeValue).

                                        $alternativeIndex := findIndexOfSumTypeAlternative(sumType. bindableTypeValue).
                                        ##printLine("alternativeIndex ". alternativeIndex).
                                        if: alternativeIndex < 0 then: {
                                            printLine("Unused bindable pattern.").
                                            abort()
                                        }.
    
                                        casesAlternativeIndex add: MidConstantInteger#{
                                            value: alternativeIndex.
                                            type: getBasicIntrinsicTypes() integer
                                        }.
                                        casesAlternativeTypes add: bindableTypeValue.
                                        casesActions add: caseAssociation value.
                                        casesBindables add: bindable.
                                    }.
                                    _: {
                                        defaultAction := caseAssociation value
                                    }
                                }.
                            } continueWith: (i := i + 1).
                        }.
                        _: {
                            printLine("Cases must be specified through an immutable dictionary.").
                            abort()
                        }

                        
                    }.

                    ## Make the case control flow
                    $switchValue := midBuilder getSumIndex: switchSumValue.
                    $switchBranch := midBuilder switchBranch: switchValue caseValues: casesAlternativeIndex asArray.

                    $caseCount := casesAlternativeIndex size.
                    $branchDestinations := Array new: caseCount.
                    ##printLine("Make switch destinations.")
                    $!i := 0. while: (i < caseCount) do: {
                        branchDestinations at: i put: (midBuilder makeBranchDestination: switchBranch)
                    } continueWith: (i := i + 1).
                    switchBranch caseDestinations: branchDestinations.
                    
                    $defaultDestination := midBuilder makeBranchDestination: switchBranch.
                    switchBranch defaultDestination: defaultDestination.
                    $switchMerge := midBuilder makeSwitchMerge: switchBranch.
                    
                    $phiMerge := midBuilder makeMergePhiNode.
                    phiMerge previousControl: switchMerge.

                    $mergePredecessors := OrderedCollection().
                    $phiValues := OrderedCollection().

                    ## Compile the case destinations
                    ##printLine("Compile the case destinations").
                    $!i := 0. while: (i < caseCount) do: {
                        midBuilder beginWithControlNode: (branchDestinations at: i).
                        midBuilder sourcePosition: switchPatternNode sourcePosition.

                        $newLexicalEnvironment := Environment(LexicalEnvironment#{
                            parent: environment.
                            localSymbols: SymbolHashtable().
                        }).

                        $bindable := casesBindables at: i.
                        $alternativeType := casesAlternativeTypes at: i.
                        $alternativeProjection := midBuilder getSumValue: switchSumValue projectionWithType: alternativeType.
                        if: bindable nameExpression isNotNull then: {
                            $bindableName := extractSymbolFromValue((self analyzeAndEvaluateWithEnvironment: environment script: bindable nameExpression) value).
                            $bindableSymbolValue := TypedValue(Value(SysmelMidValue(alternativeProjection)). alternativeType).
                            ##printLine("bindableName ". bindableName).
                            ##printLine("alternativeProjection ". alternativeProjection).
                            ##printLine("bindableSymbolValue ". bindableSymbolValue).
                            newLexicalEnvironment addLocalSymbol: bindableName withValue: bindableSymbolValue.
                        }.

                        $caseAction := casesActions at: i.
                        $caseValue := self analyzeWithEnvironment: newLexicalEnvironment andCompileClosure: midBuilder withBody: caseAction.

                        $branchPhiValue := midBuilder makePhiNodeValue.
                        branchPhiValue sourceValue: caseValue.
                        branchPhiValue destinationPhi: phiMerge.
                        branchPhiValue previousControl: midBuilder currentControlNode.
                        phiValues add: branchPhiValue.

                        $switchBranchPredecessor := midBuilder makeBranchSequenceEnd: branchPhiValue Into: switchMerge.
                        mergePredecessors add: switchBranchPredecessor.
                    } continueWith: (i := i + 1).

                    ##printLine("Compile default").
                    midBuilder beginWithControlNode: defaultDestination.
                    midBuilder sourcePosition: switchPatternNode sourcePosition.

                    $defaultValue := if: defaultAction isNotNull then: {
                        self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: defaultAction
                    } else: {
                        MidConstantVoid#{}
                    }.

                    $defaultPhiValue := midBuilder makePhiNodeValue.
                    defaultPhiValue sourceValue: defaultValue.
                    defaultPhiValue destinationPhi: phiMerge.
                    defaultPhiValue previousControl: midBuilder currentControlNode.
                    phiValues add: defaultPhiValue.

                    $defaultBranchPredecessor := midBuilder makeBranchSequenceEnd: defaultPhiValue Into: switchMerge.
                    mergePredecessors add: defaultBranchPredecessor.

                    ##printLine("Merge switch.").
                    midBuilder beginWithControlNode: switchMerge.
                    midBuilder sourcePosition: switchPatternNode sourcePosition.

                    phiMerge incomingValues: phiValues asArray.
                    phiMerge previousControl: switchMerge.
                    
                    ##printLine("Merge predecessors.". mergePredecessors asArray).
                    switchMerge predecessors: mergePredecessors asArray.
                    midBuilder beginWithControlNode: phiMerge.

                    return: phiMerge

                }.
                $(ParseTreeWhileLoopNode)whileLoopNode : {
                    midBuilder sourcePosition: whileLoopNode sourcePosition.
                    $loopPreheader := midBuilder makeLoopPreheader.
                    $loopHeader := midBuilder makeLoopHeader.
                    $loopMerge := midBuilder makeLoopMerge: loopHeader.
                    $loopContinue := midBuilder makeLoopContinue: loopHeader.
                    $loopBody := midBuilder makeLoopBody: loopHeader.

                    loopPreheader entryDestination: loopHeader.

                    loopHeader previousControl: loopPreheader.
                    midBuilder beginWithControlNode: loopHeader.
                    $condition := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: whileLoopNode condition.
                    $loopCondition := midBuilder makeLoop: loopHeader condition: condition.
                    loopCondition trueDestination: loopBody.
                    loopCondition falseDestination: loopMerge.

                    loopBody previousControl: loopCondition. 
                    midBuilder beginWithControlNode: loopBody.
                    self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: whileLoopNode body.

                    loopContinue previousControl: midBuilder currentControlNode.
                    midBuilder beginWithControlNode: loopContinue.
                    if: whileLoopNode continueExpression isNotNull then: {
                        self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: whileLoopNode continueExpression.
                    }.

                    $loopContinueEnd := midBuilder makeLoopContinueEnd: loopHeader.
                    loopContinueEnd previousControl: midBuilder currentControlNode.

                    loopHeader continuePredecessor: loopContinueEnd.

                    midBuilder beginWithControlNode: loopMerge.
                    loopMerge previousControl: loopCondition.

                    MidConstantVoid#{
                        sourcePosition: whileLoopNode sourcePosition.
                        type: getBasicIntrinsicTypes() voidType
                    }
                }.
                $(ParseTreeDoWhileLoopNode)doWhileLoop : {
                    midBuilder sourcePosition: doWhileLoop sourcePosition.
                    $loopPreheader := midBuilder makeLoopPreheader.
                    $loopHeader := midBuilder makeLoopHeader.
                    $loopMerge := midBuilder makeLoopMerge: loopHeader.
                    $loopContinue := midBuilder makeLoopContinue: loopHeader.
                    $loopBody := midBuilder makeLoopBody: loopHeader.

                    loopPreheader entryDestination: loopHeader.
                    loopHeader previousControl: loopPreheader.

                    loopBody previousControl: loopHeader.
                    midBuilder beginWithControlNode: loopBody.
                    self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: doWhileLoop body.

                    loopContinue previousControl: midBuilder currentControlNode.
                    midBuilder beginWithControlNode: loopContinue.
                    if: doWhileLoop continueExpression isNotNull then: {
                        self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: doWhileLoop continueExpression.
                    }.

                    $condition := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: doWhileLoop condition.
                    $loopCondition := midBuilder makeLoop: loopHeader condition: condition.
                    loopCondition trueDestination: loopHeader.
                    loopCondition falseDestination: loopMerge.

                    loopHeader continuePredecessor: loopCondition.

                    midBuilder beginWithControlNode: loopMerge.
                    loopMerge previousControl: loopCondition.

                    MidConstantVoid#{
                        sourcePosition: doWhileLoop sourcePosition.
                        type: getBasicIntrinsicTypes() voidType
                    }
                }.
                $(ParseTreeReturnNode)returnNode : {
                    $returnValue := self analyzeWithEnvironment: environment andCompileClosure: midBuilder withBody: returnNode valueExpression.
                    midBuilder sourcePosition: returnNode sourcePosition.
                    midBuilder returnValue: returnValue
                }.
                $(ParseTreeNamespaceDefinitionNode)namespace : {
                    namespace sourcePosition printFormatted.
                    printLine("Namespaces cannot be constructed inside of functions.").
                    abort()
                }.
                _: {
                    ast sourcePosition printFormatted.
                    printLine("Unsupported node for compilation. "#*. ast*#).
                    abort()
                }
            }.
        }.
]
}
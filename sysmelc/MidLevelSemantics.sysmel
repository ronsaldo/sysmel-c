namespace: SysmelC definition: {
public: [
    SemanticsState
        withSelector: #processDependentType:withEnvironment:forClosureFunction: addMethod: {
            | $(SemanticsState)self $(ParseTreeNode)functionDependentTypeNode $(FunctionAnalysisEnvironment)environment $(MidClosureFunction) closureFunction :: SysmelType |
            $functionDependentType := functionDependentTypeNode extractFunctionalDependentTypeNode.
            $argumentNodes := functionDependentType arguments.
            $processedArguments := OrderedCollection().
            $argumentTypes := OrderedCollection()

            $!i := 0. while: (i < argumentNodes size) do: {
                $argumentBindable := (argumentNodes at: i) extractBindableNameNode.
                
                $!argumentName := null.
                if: argumentBindable isAnonymous not then: {
                    argumentName := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: argumentBindable nameExpression.
                    argumentName := extractSymbolFromValue(argumentName value)
                }.
                $argumentTypeNode := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: argumentBindable typeExpression.
                $argumentType := extractTypeFromValue(argumentTypeNode value).
                argumentTypes add: argumentType.

                $midType := MidConstantType(argumentType).
                $midArgument := MidArgument#{
                    owner: closureFunction.
                    index: i asUInt32.
                    name: argumentName.
                    typeExpression: midType
                }.

                if: argumentBindable isAnonymous not then: {
                    Environment(environment) addLocalSymbol: argumentName withValue:
                        TypedValue(Value(SysmelMidValue(midArgument)). argumentType)
                }.

                processedArguments add: midArgument.
            } continueWith: (i := i + 1).

            closureFunction arguments: processedArguments asArray.
            $resultTypeNode := self analyzeAndEvaluateWithEnvironment: Environment(environment) script: functionDependentType resultTypeExpression.
            $resultType := extractTypeFromValue(resultTypeNode value).

            $functionType := SysmelType(SysmelSimpleFunctionType#{
                common: SysmelTypeCommon#{

                }.
                supertype: getBasicIntrinsicTypes() function.
                isCompileTimePure: false.
                isVariadic: false.
                argumentTypes: argumentTypes asArray.
                resultType: resultType.
            }).

            closureFunction type: functionType.
            functionType
        };
        withSelector: #analyzeWithEnvironment:andCompileClosure: addMethod: {
        | $(SemanticsState)self $(Environment)environment $(ParseTreeFunctionNode)ast :: TypedValue |

            $midFunction := MidClosureFunction#{
                name: ast name.
                captures: [].
                arguments: []
            }.

            $interpretedFunction := SysmelCompiledFunction#{
                name: ast name.
                midIR: midFunction.
            }.

            $analysisEnvironment := FunctionAnalysisEnvironment#{
                parent: environment.
                localSymbols: SymbolHashtable().
            }.

            self processDependentType: ast functionDependentType withEnvironment: analysisEnvironment forClosureFunction: midFunction.
            
            ##printLine(Value(SysmelFunctionValue(interpretedFunction))).
            printLine("Todo implement mid-level: #analyzeWithEnvironment:andCompileClosure:").
            abort()
        }
]
}
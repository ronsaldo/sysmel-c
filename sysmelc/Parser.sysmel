namespace: SysmelC definition: {
public: [
    Record: ParserState withFields: #{
        sourceCode: SourceCode.
        tokenCount: UInt32.
        tokens: Array.
        position: UInt32.
    }.

    ParserState
        withSelector: #atEnd addMethod: {|$(ParserState)self :: Boolean|
            self position >= self tokenCount
        };
        withSelector: #peekKind: addMethod: {|$(ParserState)self $(UInt32)offset :: asUInt8 |
            $peekPosition := self position + offset.
            if: peekPosition < self tokenCount then: {
                (self tokens at: peekPosition) kind asUInt8
            }
            else: {
                TokenKind EndOfSource
            }
        };
        withSelector: #peekKind addMethod: {|$(ParserState)self :: asUInt8 |
            self peekKind: 0u32
        };
        withSelector: #peek: addMethod: {|$(ParserState)self $(UInt32)offset :: asUInt8 |
            $peekPosition := self position + offset.
            if: peekPosition < self tokenCount then: {
                self tokens at: peekPosition
            }
            else: {
                TokenKind EndOfSource
            }
        };
        withSelector: #peek addMethod: {|$(ParserState)self :: asUInt8 |
            self peek: 0u32
        };
        withSelector: #advance addMethod: {|$(ParserState)self :: Void |
            assert: self position < self tokenCount.
            self position: self position + 1u32.
            void
        };
        withSelector: #next addMethod: {|$(ParserState)self :: ScannerToken |
            assert: self position < self tokenCount.
            $token := self tokens at: self position.
            self position: self position + 1u32.
            token
        };
        withSelector: #memento addMethod: {|$(ParserState)self :: UInt32 |
            self position
        };
        withSelector: #restoreMemento addMethod: {|$(ParserState)self $(UInt32)memento :: UInt32 |
            self position: memento
        };
        withSelector: #previousSourcePosition addMethod: {|$(ParserState)self :: SourcePosition |
            assert: self position > 0.
            (self tokens at: self position - 1u32) sourcePosition
        };
        withSelector: #currentSourcePosition addMethod: {|$(ParserState)self :: SourcePosition |
            if: self position < self tokenCount then: {
                return: (self tokens at: self position) sourcePosition
            }.

            assert: self tokenCount > 0.
            return: (self tokens at: self tokenCount - 1) sourcePosition
        };
        withSelector: #sourcePositionFrom: addMethod: {|$(ParserState)self $(UInt32)startingPosition :: SourcePosition |
            assert: startingPosition < self tokenCount.
            $startSourcePosition := (self tokens at: startingPosition) sourcePosition.
            
            if: self position > 0u32 then: {
                $endSourcePosition := self previousSourcePosition.
                startSourcePosition to: endSourcePosition
            } else: {
                $endSourcePosition := self currentSourcePosition.
                startSourcePosition until: endSourcePosition
            }
        };
        withSelector: #makeErrorAtCurrentSourcePosition: addMethod: {|$(ParserState)self $(String)errorMessage :: ParseTreeNode |
            ParseTreeNode(ParseTreeErrorNode#{
                sourcePosition: self currentSourcePosition.
                errorMessage: errorMessage.
                innerNodes: ParseTreeNullNode()
            })
        };
        withSelector: #expect:addingError:toNode: addMethod: {|$(ParserState)self $(TokenKind)expectedKind $(String)errorMessage $(ParseTreeNode)innerNode :: ParseTreeNode |
            if: self peekKind = expectedKind then: {
                self advance.
                return: innerNode
            }.

            ParseTreeNode(ParseTreeErrorNode#{
                sourcePosition: self currentSourcePosition.
                errorMessage: errorMessage.
                innerNodes: innerNode
            })
        };
        withSelector: #advanceWithExpectedError: addMethod: {|$(ParserState)self $(String)errorMessage :: ParseTreeNode |
            if: self peekKind = TokenKind Error then: {
                $errorToken := self next.

                return: ParseTreeNode(ParseTreeErrorNode#{
                    sourcePosition: errorToken sourcePosition.
                    errorMessage: errorMessage.
                    innerNodes: ParseTreeNullNode()})
            }.
            if: self atEnd then: {
                return: ParseTreeNode(ParseTreeErrorNode#{
                    sourcePosition: self currentSourcePosition.
                    errorMessage: errorMessage.
                    innerNodes: ParseTreeNullNode()})
            }.

            return: ParseTreeNode(ParseTreeErrorNode#{
                sourcePosition: self currentSourcePosition.
                errorMessage: errorMessage.
                innerNodes: ParseTreeNullNode()})
        }.

    $parseIntegerConstant($(String)text :: Integer) := {
        $!value := 0.
        $!radix := 10.
        $!hasSeenRadix := false.
        
        $i := 0.
        $stringSize := text size.
        while: i < stringSize do: {
            $c := text at: i.
            if: hasSeenRadix not && ((c = 'r') || (c = 'R')) then: {
                radix := value.
                value := 0.
                hasSeenRadix := true
            } else: {
                if: ('0' <= c) && (c <= '9') then: {
                    $digit := (c - '0') asInteger.
                    value := (value*radix) + digit
                }.
                if: ('A' <= c) && (c <= 'Z') then: {
                    $digit := (c - 'A') asInteger + 10.
                    value := (value*radix) + digit
                }.
                if: ('a' <= c) && (c <= 'z') then: {
                    $digit := (c - 'a') asInteger + 10.
                    value := (value*radix) + digit
                }.
            }
        } continueWith: (i := i + 1).

        value
    }.

    Record: Parser withFields: #{
        state: ParserState.
    }.
    Parser
        withSelector: #parseInteger addMethod: {|$(Parser)self :: ParseTreeNode |
            $token := self state next.

            ParseTreeNode(ParseTreeLiteralIntegerNode#{
                sourcePosition: token sourcePosition.
                value: parseIntegerConstant(token getText)
            })
        };
        withSelector: #parseFloat addMethod: {|$(Parser)self :: ParseTreeNode |
            $token := self state next.

            ParseTreeNode(ParseTreeLiteralFloatNode#{
                sourcePosition: token sourcePosition.
                value: token getText asFloat
            })
        };
        withSelector: #parseCharacter addMethod: {|$(Parser)self :: ParseTreeNode |
            $token := self state next.
            $characterRawText := token getText.
            $characterTrimmedText := (characterRawText substringFrom: 1 until: characterRawText size - 1) parseCEscapeSequences.

            ParseTreeNode(ParseTreeLiteralCharacterNode#{
                sourcePosition: token sourcePosition.
                value: (characterTrimmedText at: 0)
            })
        };
        withSelector: #parseString addMethod: {|$(Parser)self :: ParseTreeNode |
            $token := self state next.
            $stringRawText := token getText.
            $stringTrimmedText := (stringRawText substringFrom: 1 until: stringRawText size - 1) parseCEscapeSequences.

            ParseTreeNode(ParseTreeLiteralStringNode#{
                sourcePosition: token sourcePosition.
                value: stringTrimmedText
            })
        };
        withSelector: #parseSymbol addMethod: {|$(Parser)self :: ParseTreeNode |
            $token := self state next.
            $symbolRawText := token getText.

            if: (symbolRawText size >= 2) && (symbolRawText at: 1) = '"' then: {
                $trimmedSymbolString := (symbolRawText substringFrom: 2 until: symbolRawText size - 1) parseCEscapeSequences.
                ParseTreeNode(ParseTreeLiteralSymbolNode#{
                    sourcePosition: token sourcePosition.
                    value: trimmedSymbolString asSymbol
                })
            }
            else: {
                $trimmedSymbolString := symbolRawText substringFrom: 1 until: symbolRawText size.
                ParseTreeNode(ParseTreeLiteralSymbolNode#{
                    sourcePosition: token sourcePosition.
                    value: trimmedSymbolString asSymbol
                })
            }
        };
        withSelector: #parseLiteral addMethod: {|$(Parser)self :: ParseTreeNode |
            $kind := self state peekKind.
            if: kind = TokenKind Nat then: {
                return: self parseInteger
            }.
            if: kind = TokenKind Float then: {
                return: self parseFloat
            }.
            if: kind = TokenKind Character then: {
                return: self parseCharacter
            }.
            if: kind = TokenKind String then: {
                return: self parseString
            }.
            if: kind = TokenKind Symbol then: {
                return: self parseSymbol
            }.

            self state advanceWithExpectedError: "Expected a literal."
        };
        withSelector: #parseIdentifier addMethod: {|$(Parser)self :: ParseTreeNode |
            $token := self state next.
            $symbol := token getText asSymbol.

            ParseTreeNode(ParseTreeIdentifierReferenceNode#{
                sourcePosition: token sourcePosition.
                value: symbol
            })
        };
        withSelector: #parseParenthesis addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            ## (
            assert: self state peekKind = TokenKind LeftParent.
            self state advance.

            if: (self isBinaryExpressionOperator: self state peekKind) &&
                ((self state peekKind: 1) = TokenKind RightParent) then: {
                $token := self state next.
                self state advance.

                $tokenSymbol := token getText asSymbol.
                return: ParseTreeNode(ParseTreeIdentifierReferenceNode#{
                    sourcePosition: token sourcePosition.
                    value: tokenSymbol
                })
            }.

            if: self state peekKind = TokenKind RightParent then: {
                self state advance.
                return: ParseTreeNode(ParseTreeTupleNode#{
                    sourcePosition: (self state sourcePositionFrom: startingPosition).
                    value: []
                })
            }.
        
            $expression := self parseSequenceUntilEndOrDelimiter: TokenKind RightParent.
            $expressionWithError := self state expect: TokenKind RightParent addingError: "Missing right parenthesis" toNode: expression.
            ## )

            expressionWithError
        };
        withSelector: #parseFunctionalType addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            $arguments := OrderedCollection().
            $!resultTypeExpression := ParseTreeNode(ParseTreeNullNode()).

            while: self state peekKind = TokenKind Dollar do: {
                $argument := self parseBindableName.
                arguments add: argument
            }.

            if: self state peekKind = TokenKind ColonColon then: {
                self state advance.
                resultTypeExpression := self parseUnaryPrefixExpression
            }.

            ParseTreeNode(ParseTreeFunctionalDependentTypeNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                arguments: arguments asArray.
                resultTypeExpression: resultTypeExpression.
            })
        };
        withSelector: #parseBlock addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            ## {
            assert: self state peekKind = TokenKind LeftCurlyBracket.
            self state advance.

            $!hasFunctionalType := false.
            $!functionalType := ParseTreeNode(ParseTreeNullNode()).

            if: self state peekKind = TokenKind Bar then: {
                self state advance.
                if: self state peekKind = TokenKind Bar then: {
                    self state advance.
                    functionalType := ParseTreeNode(ParseTreeFunctionalDependentTypeNode#{
                        sourcePosition: (self state sourcePositionFrom: startingPosition).
                        arguments: [].
                        resultTypeExpression: ParseTreeNode(ParseTreeNullNode())
                    }).
                    hasFunctionalType := true.
                } else: {
                    functionalType := self parseFunctionalType.
                    functionalType := self state expect: TokenKind Bar
                        addingError: "Expected a bar (|) finalizing the block closure signature." toNode: functionalType.
                    hasFunctionalType := true
                }
            }.

            $body := self parseSequenceUntilEndOrDelimiter: TokenKind RightCurlyBracket.
            $bodyWithError := self state expect: TokenKind RightCurlyBracket addingError: "Missing right curly bracket" toNode: body.
            ## }

            if: hasFunctionalType then: {
                ParseTreeNode(ParseTreeBlockClosureNode#{
                    sourcePosition: (self state sourcePositionFrom: startingPosition).
                    functionType: functionalType.
                    body: bodyWithError.
                })
            }
            else: {
                ParseTreeNode(ParseTreeLexicalBlockNode#{
                    sourcePosition: (self state sourcePositionFrom: startingPosition).
                    expression: bodyWithError.
                })
            }
        };
        withSelector: #parseOptionalBindableNameType addMethod: {|$(Parser)self :: ParseTreeNode |
            if: self state peekKind = TokenKind LeftBracket then: {
                self state advance.
                $typeExpression := self parseExpression.
                $typeExpressionWithError := self state expect: TokenKind RightBracket addingError: "Expected a right bracket." toNode: typeExpression.
                return: typeExpressionWithError
            }.
            if: self state peekKind = TokenKind LeftParent then: {
                self state advance.
                $typeExpression := self parseExpression.
                $typeExpressionWithError := self state expect: TokenKind RightParent addingError: "Expected a right parenthesis." toNode: typeExpression.
                return: typeExpressionWithError
            }.
            return: ParseTreeNode(ParseTreeNullNode())
        };
        withSelector: #parseNameExpression addMethod: {|$(Parser)self :: ParseTreeNode |
            if: self state peekKind = TokenKind Identifier then: {
                $token := self state next.
                $tokenSymbol := token getText asSymbol.

                return: ParseTreeNode(ParseTreeLiteralSymbolNode #{
                    sourcePosition: token sourcePosition.
                    value: tokenSymbol
                })
            } else: {
                self state makeErrorAtCurrentSourcePosition: "Expected a bindable name."
            }
        };
        withSelector: #parseBindableDependentType addMethod: {|$(Parser)self :: ParseTreeNode |
            assert: self state peekKind = TokenKind LeftParent.
            self state advance.
            $functionalType := self parseFunctionalType.
            $functionalTypeWithError := self state expect: TokenKind RightParent addingError: "Missing right parenthesis." toNode: functionalType.
            return: functionalTypeWithError
        };
        withSelector: #parseBindableName addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            assert: self state peekKind = TokenKind Dollar.
            self state advance.
            
            $!isExistential := false
            $!isMutable := false.
            
            if: self state peekKind = TokenKind Bang then: {
                self state advance.
                isMutable := true.
            }.
            if: self state peekKind = TokenKind Question then: {
                self state advance.
                isExistential := true.
            }.

            $!isAnonymousFunction := false.
            if: self state peekKind = TokenKind Dollar then: {
                self state advance.
                isAnonymousFunction := true.
            }.

            $isImplicit := false.
            $!typeExpression := null.
            $!hasTypeExpression := false.
            if: isAnonymousFunction not then: {
                if: self state peekKind = TokenKind LeftBracket then: {
                    isImplicit := true.
                    hasTypeExpression := true
                }.
                if: self state peekKind = TokenKind LeftParent then: {
                    hasTypeExpression := true
                }.

                typeExpression := self parseOptionalBindableNameType.
            }.

            $!hasPostTypeExpression := false.
            $!isVariadic := false.

            $!nameExpression := ParseTreeNode(ParseTreeNullNode()).
            if: self state peekKind = TokenKind Ellipsis then: {
                self state advance.
                isVariadic := true.
            } else: {
                if: isAnonymousFunction not then: {
                    nameExpression := self parseNameExpression
                }
            }.

            if: hasTypeExpression not || isAnonymousFunction then: {
                if: self state peekKind = TokenKind LeftParent then: {
                    typeExpression := self parseBindableDependentType.
                    hasPostTypeExpression := true
                }
            }.

            if: self state peekKind = TokenKind Ellipsis then: {
                self state advance.
                isVariadic := true.
            }.

            ParseTreeNode(ParseTreeBindableNameNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                typeExpression: typeExpression.
                nameExpression: nameExpression.
                isImplicit: isImplicit.
                isExistential: isExistential.
                isVariadic: isVariadic.
                isMutable: isMutable.
                hasPostTypeExpression: hasPostTypeExpression.
            })
        };
        withSelector: #parseTerm addMethod: {|$(Parser)self :: ParseTreeNode |
            $kind := self state peekKind.
            if: kind = TokenKind Identifier then: {
                return: self parseIdentifier
            }.
            if: kind = TokenKind LeftParent then: {
                return: self parseParenthesis
            }.
            if: kind = TokenKind LeftCurlyBracket then: {
                return: self parseBlock
            }.
            if: kind = TokenKind Dollar then: {
                return: self parseBindableName
            }.
#*
    case SysmelTokenLeftBracket:
        return parser_parseArray(state);
    case SysmelTokenByteArrayStart:
        return parser_parseByteArray(state);
    case SysmelTokenDictionaryStart:
        return parser_parseDictionary(state);
*#            
            self parseLiteral
        };
        withSelector: #isUnaryPostfixToken: addMethod: {|$(Parser)self $(TokenKind)kind :: Boolean |
            (kind = TokenKind Identifier) || (kind = TokenKind LeftParent) ||
            (kind = TokenKind LeftBracket) || (kind = TokenKind LeftCurlyBracket) ||
            (kind = TokenKind ByteArrayStart) || (kind = TokenKind DictionaryStart)
        };
        withSelector: #parseUnaryPostfixExpression addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            $!receiver := self parseTerm.

            while: (self isUnaryPostfixToken: self state peekKind) do: {
                $token := self state peek.
                if: token kind = TokenKind Identifier then: {
                    self state advance.
                    $selector := token getText asSymbol.
                    $selectorNode := ParseTreeNode(ParseTreeLiteralSymbolNode#{
                        sourcePosition: token sourcePosition.
                        value: selector
                    }).

                    $unaryMessage := ParseTreeNode(ParseTreeMessageSendNode#{
                        sourcePosition: (self state sourcePositionFrom: startingPosition).
                        receiver: receiver.
                        selector: selectorNode.
                        arguments: []
                    }).

                    receiver := unaryMessage.
                }.

            }.
            receiver
        };
        withSelector: #parseQuote addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            assert: self state peekKind = TokenKind Quote.
            self state advance.

            $expression := self parseUnaryPrefixExpression.
            
            ParseTreeNode(ParseTreeQuoteNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                expression: expression
            })
        };
        withSelector: #parseQuasiQuote addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            assert: self state peekKind = TokenKind QuasiQuote.
            self state advance.

            $expression := self parseUnaryPrefixExpression.
            
            ParseTreeNode(ParseTreeQuasiQuoteNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                expression: expression
            })
        };
        withSelector: #parseQuasiUnquote addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            assert: self state peekKind = TokenKind QuasiUnquote.
            self state advance.

            $expression := self parseUnaryPrefixExpression.
            
            ParseTreeNode(ParseTreeQuasiUnquoteNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                expression: expression
            })
        };
        withSelector: #parseSplice addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            assert: self state peekKind = TokenKind Splice.
            self state advance.

            $expression := self parseUnaryPrefixExpression.
            
            ParseTreeNode(ParseTreeSpliceNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                expression: expression
            })
        };

        withSelector: #parseUnaryPrefixExpression addMethod: {|$(Parser)self :: ParseTreeNode |
            $kind := self state peekKind.
            if: kind = TokenKind Quote then: {
                return: self parseQuote
            }.
            if: kind = TokenKind QuasiQuote then: {
                return: self parseQuasiQuote
            }.
            if: kind = TokenKind QuasiUnquote then: {
                return: self parseQuasiUnquote
            }.
            if: kind = TokenKind Splice then: {
                return: self parseSplice
            }.
            self parseUnaryPostfixExpression
        };
        withSelector: #isBinaryExpressionOperator: addMethod: {|$(Parser)self $(TokenKind)kind :: Boolean |
            (kind = TokenKind Operator) || (kind = TokenKind Star) ||
            (kind = TokenKind LessThan) || (kind = TokenKind GreaterThan) ||
            (kind = TokenKind Bar)
        };
        withSelector: #parseBinaryExpressionSequence addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            $operand := self parseUnaryPrefixExpression.
            if: (self isBinaryExpressionOperator: self state peekKind) not then: {
                return: operand
            }.

            $elements := OrderedCollection().
            elements add: operand.

            while: (self isBinaryExpressionOperator: self state peekKind) do: {
                $operatorToken := self state next.
                $operatorSymbol := operatorToken getText asSymbol.

                $operatorNode := ParseTreeNode(ParseTreeLiteralSymbolNode#{
                    sourcePosition: operatorToken sourcePosition.
                    value: operatorSymbol
                }).
                elements add: operatorNode.

                $nextOperand := self parseUnaryPrefixExpression.
                elements add: nextOperand
            }.
            
            ParseTreeNode(ParseTreeBinaryOperatorSequenceNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                elements: elements asArray
            })
        };
        withSelector: #parseAssociationExpression addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            $key := self parseBinaryExpressionSequence.
            if: self state peekKind ~= TokenKind Colon then: {
                return: key
            }.
            self state advance.
            $value := self parseAssociationExpression.
            ParseTreeNode(ParseTreeAssociationNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                key: key.
                value: value
            })
        };
        withSelector: #parseKeywordApplication addMethod: {|$(Parser)self :: ParseTreeNode |
            assert: (self state peekKind = TokenKind Keyword).
            $startingPosition := self state position.
            $!selectorValue := "".
            $arguments := OrderedCollection().

            while: (self state peekKind = TokenKind Keyword) do: {
                $token := self state next.
                selectorValue := selectorValue -- token getText.

                $argument := self parseBinaryExpressionSequence.
                arguments add: argument
            }.

            $identifierSymbol := selectorValue asSymbol.
            $identifierNode := ParseTreeNode(ParseTreeIdentifierReferenceNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                value: identifierSymbol.
            }).

            ParseTreeNode(ParseTreeFunctionApplicationNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                functional: identifierNode.
                arguments: arguments asArray
            })
        };
        withSelector: #parseKeywordMessageSend addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            $receiver := self parseAssociationExpression.
            if: self state peekKind ~= TokenKind Keyword then: {
                return: receiver
            }.

            $!selectorValue := "".
            $arguments := OrderedCollection().

            while: (self state peekKind = TokenKind Keyword) do: {
                $token := self state next.
                selectorValue := selectorValue -- token getText.

                $argument := self parseBinaryExpressionSequence.
                arguments add: argument
            }.

            $selector := selectorValue asSymbol.

            $sourcePosition := self state sourcePositionFrom: startingPosition.
            $selectorNode := ParseTreeNode(ParseTreeLiteralSymbolNode#{
                sourcePosition: sourcePosition.
                value: selector.
            }).

            ParseTreeNode(ParseTreeMessageSendNode#{
                sourcePosition: sourcePosition.
                receiver: receiver.
                selector: selectorNode.
                arguments: arguments asArray.
            })
        };
        withSelector: #parseMessageCascade addMethod: {|$(Parser)self :: ParseTreeNode |
            self parseKeywordMessageSend
        };
        withSelector: #parseLowPrecedenceExpression addMethod: {|$(Parser)self :: ParseTreeNode |
            if: self state peekKind = TokenKind Keyword then: {
                return: self parseKeywordApplication
            } else: {
                return: self parseMessageCascade
            }
        };
        withSelector: #parseAssignmentExpression addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            $assignedStore := self parseLowPrecedenceExpression.
            if: self state peekKind = TokenKind Assignment then: {
                self state advance
                
                $assignedValue := self parseAssignmentExpression.
                return: ParseTreeNode(ParseTreeAssignmentNode#{
                    sourcePosition: (self state sourcePositionFrom: startingPosition).
                    store: assignedStore.
                    value: assignedValue.
                })
            }
            else: {
                return: assignedStore
            }
        };
        withSelector: #parseCommaExpression addMethod: {|$(Parser)self :: ParseTreeNode |
            $startingPosition := self state position.
            $element := self parseAssignmentExpression.
            if: self state peekKind ~= TokenKind Comma then: {
                return: element
            }.

            $elements := OrderedCollection().
            elements add: element.
            while: self state peekKind = TokenKind Comma do: {
                self state advance.
                $element := self parseAssignmentExpression.
                elements add: element.
            }.

            ParseTreeNode(ParseTreeTupleNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                elements: elements asArray
            })
        };
        withSelector: #parseExpression addMethod: {|$(Parser)self :: ParseTreeNode |
            self parseCommaExpression
        };
        withSelector: #parseExpressionListUntilEndOrDelimiter: addMethod: {|$(Parser)self $(TokenKind)delimiter :: Array |
            $expressions := OrderedCollection().

            ## Leading dots
            while: self state peekKind = TokenKind Dot do: {
                self state advance
            }.

            $!expectsExpressions := true.
            while: (self state atEnd not && (self state peekKind ~= delimiter)) do: {
                if: expectsExpressions not then: {
                    expressions add: (self state makeErrorAtCurrentSourcePosition: "Expected dot before expression.")
                }.

                $expression := self parseExpression.
                expressions add: expression.

                ## Trailing dots
                expectsExpressions := false.
                while: self state peekKind = TokenKind Dot do: {
                    expectsExpressions := true.
                    self state advance
                }.
            }.

            expressions asArray
        };
        withSelector: #parseSequenceUntilEndOrDelimiter: addMethod: {|$(Parser)self $(TokenKind)delimiter :: ParseTreeNode |
            $startingPosition := self state position.
            $expressions := self parseExpressionListUntilEndOrDelimiter: delimiter.

            if: expressions size = 1 then: {
                return: (expressions at: 0)
            }.

            ParseTreeNode(ParseTreeSequenceNode#{
                sourcePosition: (self state sourcePositionFrom: startingPosition).
                elements: expressions
            })
        };
        withSelector: #parseTopLevelExpressions addMethod: {|$(Parser)self :: ParseTreeNode |
            self parseSequenceUntilEndOrDelimiter: TokenKind EndOfSource
        }.

$parseTokenList($(SourceCode)sourceCode $(Array)tokens :: ParseTreeNode) := {
    $initialState := ParserState#{
        sourceCode: sourceCode.
        tokenCount: tokens size.
        tokens: tokens.
        position: 0.
    }.
    $parser := Parser#{state: initialState}.
    parser parseTopLevelExpressions
}.

$parseString($(String)text :: ParseTreeNode) := {
    $sourceCode := makeSourceCodeForString(text).
    $tokens := scanSourceCode(sourceCode).
    parseTokenList(sourceCode . tokens)
}.

].

##printLine(parseString("")).
##printLine(parseString("42 . 42.5 'A' ")).
##printLine(parseString("'A' . \"Hello\\n World\"")).
##printLine(parseString("#symbol . #\"Test Symbol\"")).
##printLine(parseString("identifier")).
##printLine(parseString("1 , 2")).
##printLine(parseString("if: true then: 1 else: 2")).
##printLine(parseString("a value: 42 with: 5")).
##printLine(parseString("1 + 2")).
##printLine(parseString("1 + 2 *3 - 5")).
##printLine(parseString("#first : 1")).
##printLine(parseString("1 negated")).

##printLine(parseString("$x")).
##printLine(parseString("$(Integer)x")).
##printLine(parseString("$id($(Integer)x :: Integer)")).

##printLine(parseString("{}")).
##printLine(parseString("{| |}")).}
##printLine(parseString("{|$x $y | x + y}")).
}.

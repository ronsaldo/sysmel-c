namespace: SysmelC definition: {
public: [


    Class: MidConstant withSuperclass: MidValue fields: #{
    }.

    Class: MidConstantInteger withSuperclass: MidConstant fields: #{
        value: Integer
    }.
    Class: MidConstantCharacter withSuperclass: MidConstant fields: #{
        value: Integer
    }.
    Class: MidConstantFloat withSuperclass: MidConstant fields: #{
        value: Float
    }.
    Class: MidConstantString withSuperclass: MidConstant fields: #{
        value: String
    }.
    Class: MidConstantSymbol withSuperclass: MidConstant fields: #{
        value: Symbol
    }.
    Class: MidConstantType withSuperclass: MidConstant fields: #{
        value: SysmelType
    }.
    Class: MidConstantValue withSuperclass: MidConstant fields: #{
        value: Value
    }.
    Class: MidConstantVoid withSuperclass: MidConstant fields: #{
    }.
    Class: MidGlobalValue withSuperclass: MidConstant fields: #{
        name: Symbol
    }.


    Class: MidControlNode withSuperclass: MidValue fields: #{
        previousControl: MidValue.
    }.

    Class: MidStartNode withSuperclass: MidControlNode fields: #{
        arguments: Array.
        captures: Array.
    }.

    Class: MidStopNode withSuperclass: MidControlNode fields: #{
        exitPoints: Array
    }.

    Class: MidClosureFunction withSuperclass: MidGlobalValue fields: #{
        captures: Array.
        arguments: Array.
        startNode: MidStartNode.
        stopNode: MidStopNode.
        instructionSchedule: Array
    }.
    
    Class: MidFunctionLocalValue withSuperclass: MidValue fields: #{
        owner: MidClosureFunction
    }.

    Class: MidArgument withSuperclass: MidFunctionLocalValue fields: #{
        index: UInt32.
        name: Symbol.
        typeExpression: MidValue
    }.

    Class: MidCapture withSuperclass: MidFunctionLocalValue fields: #{
        index: UInt32.
        typeExpression: MidValue
    }.

    Class: MidReturn withSuperclass: MidControlNode fields: #{
        resultValue: MidValue
    }.

    Class: MidCallFunction withSuperclass: MidControlNode fields: #{
        functional: MidValue.
        selector: MidValue.
        arguments: Array.
    }.

    Class: MidSendMessage withSuperclass: MidControlNode fields: #{
        receiver: MidValue.
        selector: MidValue.
        arguments: Array.
    }.

    Class: MidExtractCompositeElement withSuperclass: MidControlNode fields: #{
        composite: MidValue.
        index: Integer.
    }.

    Class: MidSetCompositeElement withSuperclass: MidControlNode fields: #{
        composite: MidValue.
        index: Integer.
        elementValue: MidValue.
    }.

    Class: MidConditionalBranch withSuperclass: MidControlNode fields: #{
        condition: MidValue.
        trueDestination: MidControlNode.
        falseDestination: MidControlNode.
        branchMerge: MidControlNode.
    }.
    Class: MidBranchDestinationNode withSuperclass: MidControlNode fields: #{
    }.

    Class: MidBranchMergeNode withSuperclass: MidControlNode fields: #{
        branchNode: MidControlNode.
        incomingEdges: Array.
    }.

    Class: MidBranchSequenceEnd withSuperclass: MidControlNode fields: #{
        mergeNode: MidControlNode
    }.

    Class: MidMergePhiNode withSuperclass: MidControlNode fields: #{
        incomingValues: Array.
    }.
    Class: MidPhiNodeValue withSuperclass: MidControlNode fields: #{
        sourceValue: MidValue.
        destinationPhi: MidMergePhiNode.
    }.

    Record: MidFunctionBuilder withFields: #{
        midFunction: MidClosureFunction.
        currentControlNode: MidControlNode.
        exitPoints: OrderedCollection.
        sourcePosition: SourcePosition.
    }.

    Record: MidActivationContext withFields: #{
        arguments: Array.
        scheduledInstructions: Array.
        scheduledInstructionValues: Array.
        pc: UInt32.
        hasReachedExitPoint: Boolean.
        exitPointValue: TypedValue.
    }.
].

MidValue
    withSelector: #addUser: addMethod: {
        | $(MidValue)self $(MidValue)user :: Void |
        if: self users isNull then: {
            self users: OrderedCollection()
        }.
        self users add: user.
        void
    };
    withSelector: #isConstant addMethod: {
        | $(MidValue)self :: Boolean |
        false
    };
    withSelector: #getCurrentValueForActivationContext: addMethod: {
        | $(MidValue)self $(MidActivationContext)context :: Void |
        return: (context getValueFromPC: self scheduleIndex)
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidValue)self $(MidActivationContext)context :: Void |
        printLine("subclassResponsibility #evaluateInActivationContext: ". self class).
        abort().
    }.

MidActivationContext
    withSelector: #evaluate addMethod: {
        | $(MidActivationContext)self :: TypedValue |
        self hasReachedExitPoint: false.
        $instructionCount := self scheduledInstructions size.
        while: (self pc < instructionCount) && (self hasReachedExitPoint not) do: {
            $instruction := self scheduledInstructions at: self pc.
            ##printLine(self pc ." :". instruction class).
            instruction evaluateInActivationContext: self
        }.
        if: self hasReachedExitPoint then: {
            return: self exitPointValue
        }.
        abort()
    };
    withSelector: #setValueInCurrentPC: addMethod: {
        | $(MidActivationContext)self $(TypedValue)value :: Void |
        self scheduledInstructionValues at: self pc put: value
    };
    withSelector: #getValueFromPC: addMethod: {
        | $(MidActivationContext)self $(UInt32)pc :: TypedValue |
        self scheduledInstructionValues at: pc
    };
    withSelector: #setValue:inPCOf: addMethod:  {
        | $(MidActivationContext)self $(TypedValue)value $(MidValue)targetInstruction :: Void |
        self scheduledInstructionValues at: targetInstruction scheduleIndex put: value.
        void
    };
    withSelector: #jumpToPCOf: addMethod: {
        | $(MidActivationContext)self $(MidValue)targetInstruction :: Void |
        self pc: targetInstruction scheduleIndex.
        void
    };
    withSelector: #advancePC addMethod: {
        | $(MidActivationContext)self :: Void |
        self pc: self pc + 1.
        void
    }.

MidArgument
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidStartNode)self $(MidActivationContext)context :: Void |
        context setValueInCurrentPC: (context arguments at: self index).
        context advancePC.
    }.

MidStartNode
    withSelector: #usedValues addMethod: {
        | $(MidStartNode)self :: Array |
        self arguments -- self captures
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidStartNode)self :: Void |
        {
            $!i := 0.
            $argumentCount := self arguments size.
            while: (i < argumentCount) do:
            {
                (self arguments at: i) addUser: self
            } continueWith: (i := i + 1).
        }.
        {
            $!i := 0.
            $captureCount := self captures size.
            while: (i < captureCount) do:
            {
                (self captures at: i) addUser: self
            } continueWith: (i := i + 1).
        }
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidStartNode)self $(MidActivationContext)context :: Void |
        context advancePC.
    }.

MidConditionalBranch
    withSelector: #usedValues addMethod: {
        | $(MidConditionalBranch)self :: Array |
        [self condition]
    };
    withSelector: #usedControlNodes addMethod: {
        | $(MidConditionalBranch)self :: Array |
        [self previousControl]
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidConditionalBranch)self :: Void |
        self condition addUser: self.
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidStartNode)self $(MidActivationContext)context :: Void |
        $condition := extractBooleanFromValue((self condition getCurrentValueForActivationContext: context) value).
        if: condition then: {
            context jumpToPCOf: self trueDestination
        } else: {
            context jumpToPCOf: self falseDestination
        }.
        void.
    }.
MidBranchDestinationNode
    withSelector: #usedValues addMethod: {
        | $(MidBranchDestinationNode)self :: Array |
        []
    };
    withSelector: #usedControlNodes addMethod: {
        | $(MidBranchDestinationNode)self :: Array |
        [self previousControl]
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidBranchDestinationNode)self :: Void |
        
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidStartNode)self $(MidActivationContext)context :: Void |
        context advancePC.
        void.
    }.
MidBranchMergeNode
    withSelector: #usedControlNodes addMethod: {
        | $(MidStartNode)self :: Array |
        [self branchNode ] -- self incomingEdges
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidBranchMergeNode)self :: Void |
        
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidStartNode)self $(MidActivationContext)context :: Void |
        context advancePC.
        void.
    }.

MidBranchSequenceEnd
    withSelector: #usedControlNodes addMethod: {
        | $(MidStartNode)self :: Array |
        [self previousControl ]
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidStartNode)self $(MidActivationContext)context :: Void |
        context jumpToPCOf: self mergeNode.
        void.
    }.

MidExtractCompositeElement
    withSelector: #usedValues addMethod: {
        | $(MidExtractCompositeElement)self :: Array |
        [ self composite ]
    };
    withSelector: #usedControlNodes addMethod: {
        | $(MidExtractCompositeElement)self :: Array |
        [self previousControl ]
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidExtractCompositeElement)self :: Void |
        self composite addUser: self.
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidExtractCompositeElement)self $(MidActivationContext)context :: Void |
        $composite := (self composite getCurrentValueForActivationContext: context) value.
        $extractedRecord := extractRecordFromValue(composite).
        
        $extractedValue := extractedRecord tuple at: self index.
        context setValueInCurrentPC: extractedValue.
        context advancePC.
        void.
    }.

MidSetCompositeElement
    withSelector: #usedValues addMethod: {
        | $(MidSetCompositeElement)self :: Array |
        [ self composite . self elementValue ]
    };
    withSelector: #usedControlNodes addMethod: {
        | $(MidSetCompositeElement)self :: Array |
        [self previousControl ]
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidSetCompositeElement)self :: Void |
        self composite addUser: self.
        self elementValue addUser: self.
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidExtractCompositeElement)self $(MidActivationContext)context :: Void |
        $composite := (self composite getCurrentValueForActivationContext: context) value.
        $elementValue := self elementValue getCurrentValueForActivationContext: context.
        $extractedRecord := extractRecordFromValue(composite).

        ##printLine("elementValue ". elementValue).
        
        extractedRecord tuple at: self index put: elementValue.
        context setValueInCurrentPC: TypedValue(Value(VoidValue()). getBasicIntrinsicTypes() voidType).
        context advancePC.
        void.
    }.

MidMergePhiNode
    withSelector: #usedValues addMethod: {
        | $(MidMergePhiNode)self :: Array |
        self incomingValues.
    };
    withSelector: #usedControlNodes addMethod: {
        | $(MidMergePhiNode)self :: Array |
        [self previousControl ]
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidMergePhiNode)self :: Void |
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidStartNode)self $(MidActivationContext)context :: Void |
        ## Nothing is required here. The predecessor copy takes care.
        context advancePC.
    }.

MidPhiNodeValue
    withSelector: #usedValues addMethod: {
        | $(MidPhiNodeValue)self :: Array |
        [self sourceValue]
    };
    withSelector: #usedControlNodes addMethod: {
        | $(MidPhiNodeValue)self :: Array |
        [ self previousControl  ]
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidPhiNodeValue)self :: Void |
        
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidPhiNodeValue)self $(MidActivationContext)context :: Void |
        $sourceValue := self sourceValue getCurrentValueForActivationContext: context.
        context setValueInCurrentPC: sourceValue.
        context setValue: sourceValue inPCOf: self destinationPhi.
        context advancePC
    }.

MidConstant
    withSelector: #isConstant addMethod: {
        | $(MidValue)self :: Boolean |
        true
    };
    withSelector: #getCurrentValueForActivationContext: addMethod: {
        | $(MidConstant)self $(MidActivationContext)context :: Void |
        printLine("getCurrentValueForActivationContext: subclassResponsibility ". self class).
    }.

MidConstantInteger
    withSelector: #getCurrentValueForActivationContext: addMethod: {
        | $(MidConstantInteger)self $(MidActivationContext)context :: Void |
        TypedValue(Value(IntegerValue(self value)). self type)
    }.
MidConstantFloat
    withSelector: #getCurrentValueForActivationContext: addMethod: {
        | $(MidConstantFloat)self $(MidActivationContext)context :: Void |
        TypedValue(Value(FloatValue(self value)). self type)
    }.
MidConstantString
    withSelector: #getCurrentValueForActivationContext: addMethod: {
        | $(MidConstantString)self $(MidActivationContext)context :: Void |
        TypedValue(Value(StringValue(self value)). self type)
    }.
MidConstantSymbol
    withSelector: #getCurrentValueForActivationContext: addMethod: {
        | $(MidConstantString)self $(MidActivationContext)context :: Void |
        TypedValue(Value(SymbolValue(self value)). self type)
    }.
MidConstantValue
    withSelector: #getCurrentValueForActivationContext: addMethod: {
        | $(MidConstantValue)self $(MidActivationContext)context :: Void |
        TypedValue(self value. self type).
    }.

MidStopNode
    withSelector: #usedControlNodes addMethod: {
        | $(MidStopNode)self :: Array |
        self exitPoints
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidStopNode)self :: Void |
        {
            $!i := 0.
            $exitPointCount := self exitPoints size.
            while: (i < exitPointCount) do:
            {
                (self exitPoints at: i) addUser: self
            } continueWith: (i := i + 1).
        }.
    }.

MidCallFunction
    withSelector: #usedValues addMethod: {
        | $(MidCallFunction)self :: Array |
        [self functional] -- self arguments 
    };
    withSelector: #usedControlNodes addMethod: {
        | $(MidCallFunction)self :: Array |
        [self previousControl] 
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidCallFunction)self :: Void |
        self functional addUser: self.
        {
            $!i := 0.
            $argumentCount := self arguments size.
            while: (i < argumentCount) do:
            {
                (self arguments at: i) addUser: self
            } continueWith: (i := i + 1).
        }.
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidCallFunction)self $(MidActivationContext)context :: Void |
        $functionalTypedValue := self functional getCurrentValueForActivationContext: context.

        $function := extractFunctionFromValue(functionalTypedValue value).

        $invocationArguments := OrderedCollection().
        $i := 0. while:(i < self arguments size) do: {
            $argument := (self arguments at: i) getCurrentValueForActivationContext: context.
            ##printLine("Arg". i. " ". argument).
            invocationArguments add: argument.
        } continueWith:(i := i + 1).

        match: function ofType: SysmelFunction withPatterns: #{
            $(SysmelIntrinsicPrimitive)intrinsic : {
                context setValueInCurrentPC: intrinsic implementation(invocationArguments asArray)
            }.
            $(SysmelCompiledFunction)compiledFunction : {
                context setValueInCurrentPC: (compiledFunction midIR evaluateWithArguments: invocationArguments asArray)
            }.
            _: {
                printLine("Unsupported method function kind. " . function).
                abort()
            }
        }.
        context advancePC.
    }.

MidSendMessage
    withSelector: #usedValues addMethod: {
        | $(MidSendMessage)self :: Array |
        [self receiver . self selector] -- self arguments 
    };
    withSelector: #usedControlNodes addMethod: {
        | $(MidSendMessage)self :: Array |
        [self previousControl]
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidSendMessage)self :: Void |
        self receiver addUser: self.
        self selector addUser: self.
        {
            $!i := 0.
            $argumentCount := self arguments size.
            while: (i < argumentCount) do:
            {
                (self arguments at: i) addUser: self
            } continueWith: (i := i + 1).
        }.
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidSendMessage)self $(MidActivationContext)context :: Void |
        $receiverTypedValue := self receiver getCurrentValueForActivationContext: context.
        $selectorTypedValue := self selector getCurrentValueForActivationContext: context.

        $selector := extractSymbolFromValue(selectorTypedValue value).
        $receiverType := receiverTypedValue type.
        $method := receiverType lookupSelector: selector.
        if: method value isInvalidErrorValue then: {
            printLine(method value getInvalidErrorValueMessage. " " . selector).
            abort()
        }.
        $methodFunction := extractFunctionFromValue(method value).

        $invocationArguments := OrderedCollection().
        invocationArguments add: receiverTypedValue.
        $i := 0. while:(i < self arguments size) do: {
            $argument := (self arguments at: i) getCurrentValueForActivationContext: context.
            invocationArguments add: argument.
        } continueWith:(i := i + 1).

        match: methodFunction ofType: SysmelFunction withPatterns: #{
            $(SysmelIntrinsicPrimitive)intrinsic : {
                context setValueInCurrentPC: intrinsic implementation(invocationArguments asArray)
            }.
            $(SysmelCompiledFunction)compiledFunction : {
                context setValueInCurrentPC: (compiledFunction midIR evaluateWithArguments: invocationArguments asArray)
            }.
            _: {
                printLine("Unsupported method function kind. " . methodFunction).
                abort()
            }
        }.
        context advancePC.
    }.

MidReturn
    withSelector: #usedValues addMethod: {
        | $(MidReturn)self :: Array |
        [self resultValue]
    };
    withSelector: #usedControlNodes addMethod: {
        | $(MidReturn)self :: Array |
        [self previousControl]
    };
    withSelector: #connectWithUsed addMethod: {
        | $(MidReturn)self :: Void |
        self resultValue addUser: self.
    };
    withSelector: #evaluateInActivationContext: addMethod: {
        | $(MidReturn)self $(MidActivationContext)context :: Void |
        $resultValue := self resultValue getCurrentValueForActivationContext: context.
        context setValueInCurrentPC: resultValue.
        context exitPointValue: resultValue.
        context hasReachedExitPoint: true
    }.
MidValue
    withSelector: #usedValues addMethod: {
        | $(MidValue)self :: Array |
        []
    };
    withSelector: #usedControlNodes addMethod: {
        | $(MidValue)self :: Array |
        []
    };
    withSelector: #usageTopoSort:into: addMethod: {
        | $(MidValue)self $(IdentityHashset)visitedSet $(OrderedCollection)sortedResults :: Void |
        if: (visitedSet includes: self) then: {
            return: void
        }.
        visitedSet add: self.

        {
            $usedControlNodes := self usedControlNodes.
            ##printLine(self class .": control ".).
            $!i := 0.
            while: i < usedControlNodes size do: {
                (usedControlNodes at: i)
                    usageTopoSort: visitedSet into: sortedResults
            } continueWith: (i := i + 1).
        }.

        {
            $usedValues := self usedValues.
            ##printLine(self class .": value ".).
            $!i := 0.
            while: i < usedValues size do: {
                (usedValues at: i)
                    usageTopoSort: visitedSet into: sortedResults
            } continueWith: (i := i + 1).
        }.

        sortedResults add: self
    };
    withSelector: #usageTopoSort addMethod: {
        | $(MidValue)self :: Array |

        $visitedSet := IdentityHashset().
        $sortedElements := OrderedCollection().
        self usageTopoSort: visitedSet into: sortedElements.

        sortedElements asArray
    }.
MidClosureFunction
    withSelector: #makeBuilder addMethod: {
        | $(MidClosureFunction) self :: MidFunctionBuilder |
        $startNode := MidStartNode#{
            captures: self captures.
            arguments: self arguments.
        }.
        startNode connectWithUsed.
        self startNode: startNode.

        $builder := MidFunctionBuilder#{
            midFunction: self.
            currentControlNode: startNode.
            exitPoints: OrderedCollection()
        }.
        builder
    };

    withSelector: #ensureInstructionSchedule addMethod: {
        | $(MidClosureFunction)self :: Void |
        if: self instructionSchedule isNotNull then: {
            return: void
        }.

        ## TODO: Implement GCM algorithm.
        $topoSort := self stopNode usageTopoSort.
        {
            $!i := 0. while: i < topoSort size do: {
                $instruction := topoSort at: i.
                instruction scheduleIndex: i asUInt32
            } continueWith:(i := i + 1).
        }.

        ## Re-enumerate the scheduled instructions by removing the constants
        $enumeratedInstructions := OrderedCollection().
        {
            $!i := 0. while: i < topoSort size do: {
                $instruction := topoSort at: i.
                if: instruction isConstant not then: {
                    instruction scheduleIndex: enumeratedInstructions size asUInt32.
                    enumeratedInstructions add: instruction
                }
            } continueWith:(i := i + 1).
        }.
        
        self instructionSchedule: enumeratedInstructions asArray.
        self dumpSchedule.
        self dumpGraph

    };
    withSelector: #dumpSchedule addMethod: {
        | $(MidClosureFunction)self :: Void |
        $schedule := self instructionSchedule.
        $!i := 0. while: i < schedule size do: {
            printLine(i. "  ". (schedule at: i) class)
        } continueWith: (i := i + 1)
    };
    withSelector: #dumpGraph addMethod: {
        | $(MidClosureFunction)self :: Void |
        $schedule := self instructionSchedule.

        printLine("digraph function {").

        $!i := 0. while: (i < schedule size) do: {
            $scheduledInstruction := schedule at: i.

            {
                $usedValues := scheduledInstruction usedValues.
                $!j := 0. while: (j < usedValues size) do: {
                    $usedValue := usedValues at: j.
                    print("\t". scheduledInstruction class. i).
                    printLine(" -> ". usedValue class. usedValue scheduleIndex asInteger. " [color=green];").

                } continueWith: (j := j + 1).
            }.

            {
                $usedControlNodes := scheduledInstruction usedControlNodes.
                $!j := 0. while: (j < usedControlNodes size) do: {
                    $usedControl := usedControlNodes at: j.
                    print("\t". scheduledInstruction class. i).
                    printLine(" -> ". usedControl class. usedControl scheduleIndex asInteger. " [color=blue];").

                } continueWith: (j := j + 1).
            }.
        } continueWith: (i := i + 1).

        printLine("}").
    };
    withSelector: #evaluateWithArguments: addMethod: {
        | $(MidClosureFunction)self $(Array)arguments :: TypedValue |
        self ensureInstructionSchedule.

        $activationContext := MidActivationContext#{
            arguments: arguments.
            scheduledInstructions: self instructionSchedule.
            scheduledInstructionValues: (Array new: self instructionSchedule size).
            pc: 0u32.
        }.
        activationContext evaluate
    }.

MidFunctionBuilder
    withSelector: #returnValue: addMethod: {
        | $(MidFunctionBuilder)self $(MidValue)resultValue :: MidReturnInstruction |
        $instruction := MidReturn#{
            sourcePosition: self sourcePosition.
            users: OrderedCollection().
            type: getBasicIntrinsicTypes() voidType.
            resultValue: resultValue.
            previousControl: self currentControlNode.
        }.
        instruction connectWithUsed.
        self exitPoints add: instruction.
        self currentControlNode: instruction.
        return: instruction
    };
    withSelector: #constantInteger: addMethod: {
        | $(MidFunctionBuilder)self $(Integer)constantValue :: MidConstantInteger |
        MidConstantInteger#{
            sourcePosition: self sourcePosition.
            type: getBasicIntrinsicTypes() integer.
            value: constantValue
        }.
    };
    withSelector: #constantCharacter: addMethod: {
        | $(MidFunctionBuilder)self $(Character)constantValue :: MidConstantCharacter |
        MidConstantCharacter#{
            sourcePosition: self sourcePosition.
            type: getBasicIntrinsicTypes() character.
            value: constantValue
        }.
    };
    withSelector: #constantFloat: addMethod: {
        | $(MidFunctionBuilder)self $(Float)constantValue :: MidConstantFloat |
        MidConstantFloat#{
            sourcePosition: self sourcePosition.
            type: getBasicIntrinsicTypes() float.
            value: constantValue
        }.
    };
    withSelector: #constantString: addMethod: {
        | $(MidFunctionBuilder)self $(String)constantValue :: MidConstantString |
        MidConstantString#{
            sourcePosition: self sourcePosition.
            type: getBasicIntrinsicTypes() string.
            value: constantValue
        }.
    };
    withSelector: #constantSymbol: addMethod: {
        | $(MidFunctionBuilder)self $(Symbol)constantValue :: MidConstantSymbol |
        MidConstantSymbol#{
            sourcePosition: self sourcePosition.
            type: getBasicIntrinsicTypes() symbol.
            value: constantValue
        }.
    };
    withSelector: #constantValue: addMethod: {
        | $(MidFunctionBuilder)self $(Value)constantValue :: MidConstantValue |
        MidConstantValue#{
            sourcePosition: self sourcePosition.
            type: getBasicIntrinsicTypes() symbol.
            value: constantValue
        }.
    };

    withSelector: #call:withArguments: addMethod: {
        | $(MidFunctionBuilder)self $(MidValue)functional $(Array)arguments :: MidCallFunction |
        $node := MidCallFunction#{
            previousControl: self currentControlNode.
            sourcePosition: self sourcePosition.
            functional: functional.
            arguments: arguments.
        }.
        node connectWithUsed.
        self currentControlNode: node.
        node
    };    
    withSelector: #send:to:withArguments: addMethod: {
        | $(MidFunctionBuilder)self $(MidValue)selector $(MidValue)receiver $(Array)arguments  :: MidSendMessage |
        $node := MidSendMessage#{
            previousControl: self currentControlNode.
            sourcePosition: self sourcePosition.
            receiver: receiver.
            selector: selector.
            arguments: arguments.
        }.
        node connectWithUsed.
        self currentControlNode: node.
        node
    };
    withSelector: #fromComposite:extractAtIndex:withType: addMethod: {
        | $(MidFunctionBuilder)self $(MidValue)composite $(Integer)elementIndex $(SysmelType)fieldType :: MidExtractCompositeElement |
        $node := MidExtractCompositeElement#{
            previousControl: self currentControlNode.
            sourcePosition: self sourcePosition.
            composite: composite.
            index: elementIndex.
            type: fieldType.
        }.
        node connectWithUsed.
        self currentControlNode: node.
        node
    };
    withSelector: #inComposite:insertValue:atIndex: addMethod: {
        | $(MidFunctionBuilder)self $(MidValue)composite $(MidValue)valueToInsert $(Integer)elementIndex :: MidSetCompositeElement |
        $node := MidSetCompositeElement#{
            previousControl: self currentControlNode.
            sourcePosition: self sourcePosition.
            composite: composite.
            index: elementIndex.
            elementValue: valueToInsert.
            type: getBasicIntrinsicTypes() voidType
        }.
        node connectWithUsed.
        self currentControlNode: node.
        node
    };

    withSelector: #conditionBranch: addMethod: {
        | $(MidFunctionBuilder)self $(MidValue)condition :: MidConditionalBranch |
        $node := MidConditionalBranch#{
            previousControl: self currentControlNode.
            sourcePosition: self sourcePosition.
            condition: condition.
        }.
        node connectWithUsed.
        self currentControlNode: node.
        node
    };
    withSelector: #makeBranchDestination: addMethod: {
        | $(MidFunctionBuilder)self $(MidConditionalBranch)branch :: MidBranchDestinationNode |
        $node := MidBranchDestinationNode#{
            previousControl: branch.
            sourcePosition: self sourcePosition.
        }.
    };
    withSelector: #makeBranchMerge: addMethod: {
        | $(MidFunctionBuilder)self $(MidConditionalBranch)branch :: MidBranchMergeNode |
        MidBranchMergeNode#{
            sourcePosition: self sourcePosition.
            branchNode: branch.
        }.
    };
    withSelector: #makeBranchSequenceEnd:Into: addMethod: {
        | $(MidFunctionBuilder)self $(MidControlNode)previousControl $(MidBranchMergeNode)mergeNode :: MidBranchSequenceEnd |
        MidBranchSequenceEnd#{
            sourcePosition: self sourcePosition.
            previousControl: previousControl.
            mergeNode: mergeNode.
        }.
    };
    withSelector: #makePhiNodeValue addMethod: {
        | $(MidFunctionBuilder)self :: MidPhiNodeValue |
        MidPhiNodeValue#{
            sourcePosition: self sourcePosition.
        }.
    };
    withSelector: #makeMergePhiNode addMethod: {
        | $(MidFunctionBuilder)self :: MidMergePhiNode |
        MidMergePhiNode#{
            sourcePosition: self sourcePosition.
        }.
    };
    withSelector: #beginWithControlNode: addMethod: {
        | $(MidFunctionBuilder)self $(MidControlNode)controlNode :: Void |
        self currentControlNode: controlNode
    };
    withSelector: #finish addMethod: {
        | $(MidFunctionBuilder)self :: Void |
        $stopNode := MidStopNode#{
            exitPoints: self exitPoints asArray
        }.
        stopNode connectWithUsed.
        self midFunction stopNode: stopNode
    }.
}

